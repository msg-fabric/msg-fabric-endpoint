import TestHub from './_test_hub.jsy'

function debug(...args) :: console.log @ ...args

async function main() ::
  const hub = new TestHub()

  debug()
  const tgt_aaa = hub.endpoint @ ep_aaa
  debug @: tgt_aaa

  debug()
  const tgt_bbb = hub.endpoint @ ep_bbb
  debug @: tgt_bbb

  debug()

  function ep_aaa(ep) ::
    debug @ 'AAA initialize'

    ep.recvCtrl = function(msg, info) ::
      debug @ 'AAA CTRL', msg

    ep.recvStream = function(msg, info) ::
      debug @ '\nAAA RECV STREAM:', msg
      const parts = []
      return @{} msg, info, parts
        on_init(data, pkt) ::
          return this
        on_data(data, pkt) ::
          debug @ 'STREAM', data
          parts.push @ ...data
        on_end(res, pkt) ::
          debug @ 'STREAM END'
          return this
        on_error(err, pkt) ::
          debug @ 'STREAM ERR', err, pkt.info

    return @{}
      on_ready() ::
        debug @ 'AAA ready'

        const token = 1942
        debug @ 'AAA sending "hello" with token ${token}'
        ep.to(tgt_bbb)
          .with @: token, trailer: {awesome: true}
          .send @: say: 'hello'

        debug @ 'SEND ping'
        ep.to(tgt_bbb).ping()
          .then @ ans => debug("AAA CTRL pong() reply:", ans.msg)

      on_msg(msg, pkt) ::
        debug()
        debug @ 'AAA recv:', msg.msg
        debug()

  function ep_bbb(ep) ::
    debug @ 'BBB initialize'

    ep.recvCtrl = function(msg, info) ::
      debug @ 'BBB CTRL', msg

    return @{}
      on_ready() ::
        debug @ 'BBB ready'

      async on_msg(msg, pkt) ::
        debug()
        debug @ 'BBB recv:', msg.msg
        debug()

        const reply = ep.to(msg.info)

        if 0 ::
          setTimeout @ ()=>null, 6000
          reply.monitor().then @ monitor =>
            console.log @ 'Monitor expired:', monitor
        if 1 ::
          reply.send @: reply: 'salut'

        if 1 ::
          reply.send @: reply: 'Salut! '.repeat(1200)
          reply.send @: reply: 'ABCDEF '.repeat(1200)

        if 1 ::
          await sleep(10)
          const out = reply.stream({aStream: true})
          for let idx = 0; idx<5; idx++ ::
            out.write @: idx, ts: new Date()
            await sleep(10)
          out.end @: idx: 'done', ts: new Date()

function sleep(ms) ::
  return new Promise @ resolve => setTimeout @ resolve, ms

if module === require.main ::
  main().catch @ console.error
  process.on @ 'unhandledRejection', (reason, p) => ::
    console.log @ 'Unhandled Rejection at:', p, 'reason:', reason
