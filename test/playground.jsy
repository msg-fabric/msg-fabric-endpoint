require('source-map-support').install()

import TestHub from './_test_hub'

function debug(...args) :: console.log @ ...args
function debug_obj(obj) :: console.dir @ obj, @{} colors: true

async function main() ::
  const hub = new TestHub()

  debug()
  const tgt_aaa = hub.endpoint @ ep_aaa
  debug(tgt_aaa)
  debug_obj @: tgt_aaa, as_json: tgt_aaa.toJSON()

  debug()
  const tgt_bbb = hub.endpoint @ ep_bbb
  debug(tgt_bbb)
  debug_obj @: tgt_bbb, as_json: tgt_bbb.toJSON()

  debug()

  function ep_aaa(ep) ::
    ep.id.uri = 'I am AAA'
    debug @ 'AAA initialize', ep

    ep.recvCtrl = function(msg, info, is_reply) ::
      debug @ 'AAA CTRL', msg
      if is_reply :: return msg

    ep.recvStream = function(msg, info) ::
      debug @ '\nAAA NEW STREAM:', msg
      const parts = msg.parts = []
      return @{} msg, info, sender: ep.as_sender(info)
        //on_init(msg) :: return this
        on_data(data, pkt) ::
          debug @ 'STREAM DATA', data
          parts.push @ data
        on_end() ::
          debug @ 'STREAM END'
          return this
        on_error(err, pkt) ::
          debug @ 'STREAM ERR', err, pkt.info

    return @{}
      async on_ready() ::
        debug @ 'AAA ready'

        debug @ 'AAA sending "hello"'
        await ep.to(tgt_bbb).send @: say: 'hello'

        debug @ 'SEND ping'
        ep.to(tgt_bbb).ping()
          .reply.then @ ans => debug @ "AAA CTRL pong() reply:", ans

      async on_msg({msg, sender}, pkt) ::
        debug()
        debug @ 'AAA recv:', msg, 'from:', sender
        debug()
        if msg.self_as_obj ::
          await msg.self_as_obj.send @:
            bouncy: msg.self_as_obj

  function ep_bbb(ep) ::
    ep.id.uri = 'I am BBB'
    debug @ 'BBB initialize', ep

    ep.recvCtrl = function(msg, info, is_reply) ::
      debug @ 'BBB CTRL', msg
      if is_reply :: return msg

    return @{}
      async on_ready() ::
        debug @ 'BBB ready'

      async on_msg({msg, info}, pkt) ::
        debug()
        debug @ 'BBB recv:', msg
        debug_obj @ info
        debug()

        if msg.bouncy ::
          await msg.bouncy.send @: dbl_bounce: true
          //ep.to(msg.bouncy).send @: dbl_bounce: true
          return
        else if msg.dbl_bounce ::
          return // stop here

        console.log @ 'REPLY:', info
        const reply = ep.to(info)

        if 0 ::
          setTimeout @ ()=>null, 6000
          reply.monitor().then @ monitor =>
            console.log @ 'Monitor expired:', monitor
        if 1 ::
          await reply.send @: text: 'salut', self_as_obj: ep

        if 0 ::
          await reply.send @: text: 'Salut! '.repeat(1200)
          await reply.send @: text: 'ABCDEF '.repeat(1200)

        if 1 ::
          await sleep(10)
          const out = reply.stream @: aStream: true
          for let idx = 0; idx<5; idx++ ::
            for let j = 0; j<idx; j++ ::
              out.write @: idx, j, ts: new Date()
            await sleep(10)
          out.end @: idx: 'done', ts: new Date()

function sleep(ms) ::
  return new Promise @ resolve => setTimeout @ resolve, ms

if module === require.main ::
  main().catch @ console.error
  process.on @ 'unhandledRejection', (reason, p) => ::
    console.log @ 'Unhandled Rejection at:', p, 'reason:', reason
