import TestHub from './_test_hub'

function debug(...args) :: console.log @ ...args
function debug_obj(obj) :: console.dir @ obj, @{} colors: true

async function main() ::
  const hub = new TestHub()

  debug()
  const tgt_aaa = hub.endpoint @ ep_aaa
  debug(tgt_aaa)
  debug_obj @: tgt_aaa, as_json: tgt_aaa.toJSON()

  debug()
  const tgt_bbb = hub.endpoint @ ep_bbb
  debug(tgt_bbb)
  debug_obj @: tgt_bbb, as_json: tgt_bbb.toJSON()

  debug()

  function ep_aaa(ep) ::
    debug @ 'AAA initialize'

    ep.recvCtrl = function(msg, info) ::
      debug @ 'AAA CTRL', msg

    ep.recvStream = function(msg, info) ::
      debug @ '\nAAA NEW STREAM:', msg
      const parts = msg.parts = []
      return @{} msg, info
        on_data(data, pkt) ::
          debug @ 'STREAM DATA', data
          parts.push @ data
        on_end(res, pkt) ::
          debug @ 'STREAM END'
          return this
        on_error(err, pkt) ::
          debug @ 'STREAM ERR', err, pkt.info

    return @{}
      on_ready() ::
        debug @ 'AAA ready'

        const token = 1942
        debug @ 'AAA sending "hello" with token ${token}'
        ep.to(tgt_bbb)
          .with @: token, trailer: {awesome: true}
          .send @: say: 'hello'

        debug @ 'SEND ping'
        ep.to(tgt_bbb).ping()
          .then @ ans => debug("AAA CTRL pong() reply:", ans.msg)

      on_msg({msg}, pkt) ::
        debug()
        debug @ 'AAA recv:', msg
        debug()
        if msg.self_as_obj ::
          msg.self_as_obj().send @:
            bouncy: msg.self_as_obj

  function ep_bbb(ep) ::
    debug @ 'BBB initialize'

    ep.recvCtrl = function(msg, info) ::
      debug @ 'BBB CTRL', msg

    return @{}
      on_ready() ::
        debug @ 'BBB ready'

      async on_msg({msg, info}, pkt) ::
        debug()
        debug @ 'BBB recv:', msg
        debug()

        if msg.bouncy ::
          msg.bouncy().send @: dbl_bounce: true
          return
        else if msg.dbl_bounce :: return

        const reply = ep.to(info)

        if 0 ::
          setTimeout @ ()=>null, 6000
          reply.monitor().then @ monitor =>
            console.log @ 'Monitor expired:', monitor
        if 1 ::
          reply.send @: reply: 'salut', self_as_obj: ep

        if 1 ::
          reply.send @: reply: 'Salut! '.repeat(1200)
          reply.send @: reply: 'ABCDEF '.repeat(1200)

        if 1 ::
          await sleep(10)
          const out = reply.stream({aStream: true})
          for let idx = 0; idx<5; idx++ ::
            for let j = 0; j<idx; j++ ::
              out.write @: idx, j, ts: new Date()
            await sleep(10)
          out.end @: idx: 'done', ts: new Date()

function sleep(ms) ::
  return new Promise @ resolve => setTimeout @ resolve, ms

if module === require.main ::
  main().catch @ console.error
  process.on @ 'unhandledRejection', (reason, p) => ::
    console.log @ 'Unhandled Rejection at:', p, 'reason:', reason
