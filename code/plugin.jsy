import init_protocol from './protocol/index.jsy'
import EndpointBase from './endpoint.jsy'
import EPTargetBase from './ep_target.jsy'
import SinkBase from './sink.jsy'
import MsgCtxBase from './msgctx.jsy'

const default_plugin_options = @:
  plugin_name: 'endpoint'
  on_msg({msg, reply, info}) ::
    console.warn @ 'ENDPOINT MSG:', @{} msg, reply, info
  on_send_error(ep, err) ::
    console.error @ 'ENDPOINT SEND ERROR:', err
    ep.shutdown()
  on_recv_error(ep, err, extra) ::
    console.error @ 'ENDPOINT RECV ERROR:', err, extra
    // const {msg, pkt} = extra
    // return false to prevent auto-shutdown
  on_shutdown(ep, err, extra) ::
    // const {msg, pkt} = extra
    console.error @ `ENDPOINT SHUTDOWN: ${err.message}`

  subclass(classes) ::
    //const {Endpoint, EPTarget, Sink, MsgCtx, protocols} = classes
    return classes

  json_pack: JSON.stringify
  createMap() :: return new Map() // LRUMap, HashbeltMap
  createCacheMap() :: return new Map() // LRUMap, HashbeltMap


export default function(plugin_options) ::
  plugin_options = Object.assign @ {}, default_plugin_options, plugin_options
  const @{}
    plugin_name, random_id, json_pack
    on_msg: default_on_msg
    on_send_error: default_on_send_error
    on_recv_error: default_on_recv_error
    on_shutdown: default_on_shutdown
    createMap, createCacheMap
  = plugin_options

  return @: order: 1, subclass, post
  
  function subclass(FabricHub_PI, bases) ::
    const {packetParser} = FabricHub_PI.prototype
    if null==packetParser || ! packetParser.isPacketParser() ::
      throw new TypeError @ `Invalid packetParser for plugin`
    
    FabricHub_PI.prototype[plugin_name] =
      bindEndpointApi @ packetParser

  function post(hub) ::
    return hub[plugin_name] = hub[plugin_name](hub)

  function bindEndpointApi(packetParser) ::
    const protocols = init_protocol @ packetParser, @{} random_id, json_pack

    const {Endpoint, EPTarget, Sink, MsgCtx} =
      plugin_options.subclass @:
        protocols,
        Sink: SinkBase.forProtocols(protocols)
        MsgCtx: MsgCtxBase.forProtocols(protocols)
        Endpoint: EndpointBase.subclass({createMap})
        EPTarget: EPTargetBase.subclass(protocols)

    return function(hub) ::
      const resolveRouteChannel = hub.bindRouteChannel @ null, createCacheMap()
      return Object.assign @ endpoint, @: create, server: endpoint, client, clientEndpoint


      function endpoint(on_init) ::
        const targets = hub.router.targets
        do var id_target = random_id()
        while targets.has @ id_target
        return create @ id_target, on_init

      function create(id_target, on_init) ::
        const from_id = @{} id_target, id_router: hub.router.id_self
        const msg_ctx = new MsgCtx @ from_id, resolveRouteChannel
        const ep_tgt = new EPTarget(msg_ctx.from_id)
        const ep = new Endpoint(msg_ctx, ep_tgt)

        const ready = Promise
          .resolve @ on_init(ep, hub)
          .then @ _after_init

        return Object.defineProperties @ ep_tgt, @{}
          ready: @{} value: ready.then @ () => ep_tgt


        function _after_init(target) ::
          if null == target ::
            throw new TypeError @ `Expected endpoint init to return a closure or interface`

          const on_msg = (target.on_msg || ('function' === typeof target ? target : default_on_msg)).bind(target)
          const on_send_error = (target.on_send_error || default_on_send_error).bind(target, ep)
          const on_recv_error = (target.on_recv_error || default_on_recv_error).bind(target, ep)
          const on_shutdown = (target.on_shutdown || default_on_shutdown).bind(target, ep)

          ready.catch @ on_send_error

          const json_unpack = target.json_unpack
            ? target.json_unpack.bind(target)
            : EPTarget.jsonUnpack(msg_ctx)

          const sink = new Sink @ json_unpack
          sink.register @ ep, hub, id_target,
            @{} on_msg, on_recv_error, on_shutdown

          return target.on_ready
            ? target.on_ready(ep, hub)
            : target



      function clientEndpoint(on_ready) ::
        let ep_tgt, done = new Promise @ (resolve, reject) => ::
          ep_tgt = endpoint @ ep => @:
            async on_ready(ep, hub) ::
              resolve @ await on_ready(ep, hub)
              ep.shutdown()

            on_shutdown(ep) :: reject()
            on_send_error(ep, err) :: reject(err)

        return Object.assign @ ep_tgt, @{}
          then(y,n) :: return done.then(y,n)
          catch(n) :: return done.catch(n)
          finally(cb) :: return done.then(cb, cb)
          done


      function client(...args) ::
        if 1 === args.length && 'function' === typeof args[0] ::
          return clientEndpoint(args[0])

        const msg_ctx = new MsgCtx @ null, resolveRouteChannel
        return 0 !== args.length ? msg_ctx.to(...args) : msg_ctx

