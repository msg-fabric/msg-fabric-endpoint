import { o_create, o_assign } from './_utils'
import ep_proto from './ep_kinds/index.jsy'
import ep_mixin_api from './endpoint.jsy'
import sink from './sink.jsy'

const default_plugin_options = @{}
  plugin_name: 'endpoint'

  //on_msg({msg, pkt, reply, anon}) ::
  //  console.warn @ 'ENDPOINT MSG:', pkt
  on_warn(ep, msg, extra) ::
    console.warn @ 'ENDPOINT WARN:', msg
  on_error(ep, err, extra) ::
    console.error @ 'ENDPOINT ERROR:', err
  on_shutdown(ep, err, extra) ::
    console.error @ `ENDPOINT SHUTDOWN: ${err.message}`


export default endpoint_plugin
export function endpoint_plugin(plugin_options) ::
  plugin_options = o_assign @ {}, default_plugin_options, plugin_options

  const fallback = @{} __proto__: null
    on_msg: plugin_options.on_msg
    on_error: plugin_options.on_error
    on_shutdown: plugin_options.on_shutdown

  return function(hub) ::
    const random = hub.data_utils.random

    const pi_endpoint = endpoint.bind(null)
    o_assign @ pi_endpoint, @{}
      endpoint, create, newTargetId
      tgt_router: hub.local
      ep_msgs: o_create(hub.msgs)
      ep_mixin_api: o_assign({}, ep_mixin_api)

    Object.setPrototypeOf @ pi_endpoint, ep_proto
    pi_endpoint._apply_extensions_(hub)
    return hub[plugin_options.plugin_name] = pi_endpoint

    function endpoint(tgt) ::
      const self = this || pi_endpoint
      return self.create @ self.newTargetId(), tgt

    function newTargetId() ::
      return random(6, true)

    function create(id_target, target) ::
      const self = this || pi_endpoint
      const tgt_router = self.tgt_router

      const ep0 = self.ep_msgs.as @: id_target, id_route: tgt_router.id_route
      // capture the _recv_ method
      const _recv_ = ep0._recv_; delete ep0._recv_
      const ep = o_assign @ ep0, self.ep_mixin_api

      // use target to extended ep; see abstract.jsy for notes
      const registered = Promise
        .resolve @
          'function' === typeof target ? target(ep, hub)
          : 'function' === typeof target.on_init
            ? _on_init(target, ep, hub)
            : target
        .then @ _after_init

      const ready = registered
        .then @ _after_registered

      ::
        const ep_tgt = ep.toJSON(), fn_tgt = () => ep_tgt
        ep_tgt.ready = ready.then @ fn_tgt

        const res = registered.then @ fn_tgt
        o_assign @ res, ep_tgt
        res.toJSON = ep.toJSON
        return res


      function _after_init(tgt) ::
        if null == tgt ::
          throw new TypeError @ `Expected endpoint init to return a closure or interface`

        tgt_router.registerTarget @ id_target,
          sink @ _recv_, ep, tgt, fallback

        return tgt

      async function _after_registered(tgt) ::
        try ::
          return await @
            tgt.on_ready ? tgt.on_ready(ep, hub) : tgt
        catch err ::
          tgt.on_error @ ep, err

async function _on_init(target, ep, hub) ::
  await target.on_init(ep, hub)
  return target
