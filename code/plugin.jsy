import ep_proto from './ep_kinds/index.jsy'
import sink from './sink.jsy'

const default_plugin_options = @{}
  plugin_name: 'endpoint'

  on_msg(pkt) ::
    console.warn @ 'ENDPOINT MSG:', pkt
  on_warn(ep, msg, extra) ::
    console.warn @ 'ENDPOINT WARN:', msg
  on_send_error(ep, err, extra) ::
    // TODO: plumb through ep.on_send_error
    console.error @ 'ENDPOINT SEND ERROR:', err
  on_error(ep, err, extra) ::
    console.error @ 'ENDPOINT ERROR:', err
    // return false to prevent auto-shutdown
  on_shutdown(ep, err, extra) ::
    console.error @ `ENDPOINT SHUTDOWN: ${err.message}`


export default endpoint_plugin
export function endpoint_plugin(plugin_options) ::
  plugin_options = Object.assign @ {}, default_plugin_options, plugin_options

  const fallback = @{} __proto__: null
    on_msg: plugin_options.on_msg
    on_error: plugin_options.on_error
    on_shutdown: plugin_options.on_shutdown

  return function(hub) ::
    const pi_msgs = hub.msgs, random = hub.data_utils.random

    const pi = createEndpointPlugin(hub.local)
    pi.createEndpointPlugin = createEndpointPlugin
    return hub[plugin_options.plugin_name] = pi

    function createEndpointPlugin(tgt_router) ::
      const {id_route} = tgt_router

      Object.setPrototypeOf @ endpoint, ep_proto
      return Object.assign @ endpoint, @{} endpoint, create

      function endpoint(on_init) ::
        return create @ random(6, true), on_init

      function create(id_target, on_init) ::
        const ep = pi_msgs.as @: id_target, id_route
        // capture the _recv_ method
        const _recv_ = ep._recv_; delete ep._recv_

        // use on_init to extended ep; see abstract.jsy for notes
        const ready = Promise
          .resolve @ 'function' === typeof on_init ? on_init(ep, hub) : on_init
          .then @ _after_init

        ::
          const ep_tgt = ep.toJSON()
          return Object.defineProperties @ ep_tgt, @{}
            ready: @{} value: ready.then @ () => ep_tgt


        function _after_init(tgt) ::
          if null == tgt ::
            throw new TypeError @ `Expected endpoint init to return a closure or interface`

          tgt_router.registerTarget @ id_target,
            sink @ _recv_, ep, tgt, fallback

          return tgt.on_ready ? tgt.on_ready(ep, hub) : tgt

