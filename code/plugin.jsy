import init_protocol from './protocol/index.jsy'
import {encodeEndpoint, jsonUnpackEndpoints} from './json_endpoint.jsy'
import EndpointBase from './endpoint.jsy'
import SinkBase from './sink.jsy'
import MsgCtxBase from './msgctx.jsy'

const default_plugin_options = @:
  on_error(err, {msg, pkt}) ::
    console.error @ 'ENDPOINT ERROR:', err, @{} msg, pkt
    // return false to prevent auto-shutdown
  on_shutdown(err, {msg, pkt}) ::
    console.error @ 'ENDPOINT SHUTDOWN:' + err

  subclass({Sink, Endpoint, MsgCtx, protocols}) ::

  msg_unpack: jsonUnpackEndpoints
  msg_pack() :: return JSON.stringify


export default function(plugin_options) ::
  plugin_options = Object.assign @ {}, default_plugin_options, plugin_options
  const @{}
    random_id, msg_unpack, msg_pack
    on_error: default_on_error
    on_shutdown: default_on_shutdown
  = plugin_options

  return @: order: 1, subclass, post
  
  function subclass(FabricHub_PI, bases) ::
    const {packetParser} = FabricHub_PI.prototype
    if null==packetParser || ! packetParser.isPacketParser() ::
      throw new TypeError @ `Invalid packetParser for plugin`
    
    FabricHub_PI.prototype.endpoint =
      bindEndpointApi @ packetParser

  function post(hub) ::
    return hub.endpoint = hub.endpoint(hub)

  function bindEndpointApi(packetParser) ::
    const protocols = init_protocol @ packetParser, @{} random_id, json_pack: msg_pack()
    const Sink = SinkBase.forProtocols(protocols)
    const MsgCtx = MsgCtxBase.forProtocols(protocols)
    const Endpoint = EndpointBase.forProtocols(protocols)

    plugin_options.subclass @:
      Sink, Endpoint, MsgCtx, protocols

    return function(hub) ::
      return Object.assign @ endpoint, @: create, server: endpoint, client

      function client(...args) ::
        const msg_ctx = MsgCtx.from @ null, hub
        return 0 !== args.length
          ? msg_ctx.with(...args) : msg_ctx

      function endpoint(on_init) ::
        return create @ random_id(), on_init

      function create(id_target, on_init) ::
        const msg_ctx = MsgCtx.from @ id_target, hub
        const ep = new Endpoint(msg_ctx)

        const target = on_init(ep, hub)
        const on_msg = (target.on_msg || target).bind(target)
        const on_error = (target.on_error || default_on_error).bind(target)
        const on_shutdown = (target.on_shutdown || default_on_shutdown).bind(target)

        const sink = new Sink @ ep.json_unpack || msg_unpack(ep)
        sink.register @ ep, hub, id_target,
          @{} on_msg, on_error, on_shutdown

        let ready = Promise.resolve(target)
        if target.on_ready ::
          ready = ready.then @ target => target.on_ready()

        const res = Object.create @ endpoint_target_api, @:
          id_router: @{} enumerable: true, value: hub.router.id_self
          id_target: @{} enumerable: true, value: id_target
          ready: @{} value: ready.then @ () => res
        return res

const endpoint_target_api = @:
  valueOf() :: return 0 | this.id_target
  inspect() :: return `«Endpoint Target ${encodeEndpoint(this, true)}»`
  toJSON() :: return encodeEndpoint(this)
