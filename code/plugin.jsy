import init_protocol from './protocol/index.jsy'
import EndpointBase from './endpoint.jsy'
import SinkBase from './sink.jsy'

const default_plugin_options = @:
  on_error: console.error
  customize({Sink, Endpoint, SourceEndpoint, protocols}) ::


export default function(plugin_options) ::
  plugin_options = Object.assign @ {}, default_plugin_options, plugin_options
  const @{}
    random_id
    on_error: default_on_error
  = plugin_options

  return @: order: 1, subclass, post
  
  function subclass(FabricHub_PI, bases) ::
    const {packetParser} = FabricHub_PI.prototype
    if null==packetParser || ! packetParser.isPacketParser() ::
      throw new TypeError @ `Invalid packetParser for plugin`
    
    FabricHub_PI.prototype.endpoint =
      bindEndpointApi @ packetParser

  function post(hub) ::
    return hub.endpoint = hub.endpoint(hub)

  function bindEndpointApi(packetParser) ::
    const protocols = init_protocol @ packetParser, random_id
    const Sink = SinkBase.forProtocols(protocols)
    const EndpointBase_P = EndpointBase.forProtocols(protocols)
    class SourceEndpoint extends EndpointBase_P {}
    class Endpoint extends EndpointBase_P {}
    Endpoint.prototype.random_id = random_id

    plugin_options.customize @:
      Sink, SourceEndpoint, Endpoint, protocols

    return function(hub) ::
      return Object.assign @ endpoint, @: source, create: endpoint

      function source() ::
        return new SourceEndpoint(null, hub)

      function endpoint(on_message, on_error) ::
        if 'function' !== typeof on_message ::
          throw new TypeError @ `Expected 'on_message' function`
        if 'function' !== typeof on_error ::
          on_error = default_on_error
          if 'function' !== typeof on_error ::
            throw new TypeError @ `Expected 'on_error' function`

        const id_target = random_id()
        const ep = new Endpoint(id_target, hub)

        Sink.register @ ep, @{}
          hub, id_target, on_message, on_error

        const ready = Promise.resolve(ep).then(on_message)
        ready.catch(on_error)

        return Object.create @ endpoint_target_api, @:
          ready: @{} value: ready
          id_router: @{} enumerable: true, value: hub.router.id_self
          id_target: @{} enumerable: true, value: id_target

const endpoint_target_api = @:
  valueOf() :: return 0 | this.id_target
  inspect() :: return `«Endpoint Target ${this.id_target}»`

  then(fa, fb) :: return this.ready.then(fa, fb)
  catch(fn) :: return this.ready.catch(fn)
  finally(fn) :: return this.ready.finally(fn)

