import ep_proto from './ep_kinds/index.jsy'
import SinkBase from './sink.jsy'
import MsgCtxBase from './msgctx.jsy'
import EndpointBase from './endpoint.jsy'

const default_plugin_options = @:
  plugin_name: 'endpoint'
  protocols: 'protocols'
  createMap() :: return new Map() // LRUMap, HashbeltMap

  on_msg({msg, reply, info}) ::
    console.warn @ 'ENDPOINT MSG:', @{} msg, reply, info
  on_error(ep, err, extra) ::
    console.error @ 'ENDPOINT ERROR:', err
    // const {msg, pkt} = extra
    // return false to prevent auto-shutdown
  on_shutdown(ep, err, extra) ::
    // const {msg, pkt} = extra
    console.error @ `ENDPOINT SHUTDOWN: ${err.message}`

  subclass(classes) ::
    //const {Endpoint, Sink, MsgCtx, protocols} = classes
    return classes


export default function(plugin_options) ::
  plugin_options = Object.assign @ {}, default_plugin_options, plugin_options
  const @{}
    createMap
    on_msg: default_on_msg
    on_error: default_on_error
    on_shutdown: default_on_shutdown
  = plugin_options

  if plugin_options.ep_kinds ::
    Object.assign @ ep_proto, plugin_options.ep_kinds

  let endpoint_plugin
  return @:
    order: 1
    subclass
    post(hub) ::
      return hub[plugin_options.plugin_name] = endpoint_plugin(hub)


  function get_protocols(hub_prototype) ::
    const res = plugin_options.protocols
    if 'string' === typeof res ::
      return hub_prototype[res]
    else if 'function' === typeof res ::
      return plugin_options.protocols @
        hub_prototype.protocols, hub_prototype
    else if null == res ::
      return hub_prototype.protocols
    else return res


  function subclass(FabricHub_PI, bases) ::
    const protocols = get_protocols @ FabricHub_PI.prototype

    const {Endpoint, Sink, MsgCtx: MsgCtx_pi} =
      plugin_options.subclass @:
        Sink: SinkBase.forProtocols(protocols)
        MsgCtx: MsgCtxBase.forProtocols(protocols)
        Endpoint: EndpointBase.subclass({createMap})

    endpoint_plugin = function (hub) ::
      const channel = hub.connect_self()
      const MsgCtx = MsgCtx_pi.forHub(hub, channel)

      Object.setPrototypeOf @ endpoint, ep_proto
      Object.assign @ endpoint, @{} endpoint, create, MsgCtx
      return endpoint


      function endpoint(on_init) ::
        const targets = hub.router.targets
        do var id_target = protocols.random_id()
        while targets.has @ id_target
        return create @ id_target, on_init

      function create(id_target, on_init) ::
        const handlers = Object.create(null)
        const id = @{} id_target, id_router: hub.router.id_self
        const ep = new Endpoint @ id, MsgCtx

        const ready = Promise
          .resolve @
            'function' === typeof on_init
              ? on_init(ep, hub)
              : on_init
          .then @ _after_init

        // Allow for both internal and external error handling by forking ready.catch
        ready.catch @ err => handlers.on_error @ err, @{} zone:'on_ready'

        ::
          const ep_tgt = ep.ep_self()
          return Object.defineProperties @ ep_tgt, @{}
            ready: @{} value: ready.then @ () => ep_tgt


        function _after_init(target) ::
          if null == target ::
            throw new TypeError @ `Expected endpoint init to return a closure or interface`

          handlers.on_msg = (target.on_msg || ('function' === typeof target ? target : default_on_msg)).bind(target)
          handlers.on_error = (target.on_error || default_on_error).bind(target, ep)
          handlers.on_shutdown = (target.on_shutdown || default_on_shutdown).bind(target, ep)

          new Sink().register @ ep, hub, id_target, handlers

          return target.on_ready ? target.on_ready(ep, hub) : target


