import ep_proto from './ep_kinds/index.jsy'
import as_endpoint_api from './endpoint.jsy'
import sink from './sink.jsy'

const default_plugin_options = @{}
  plugin_name: 'endpoint'

  on_msg(pkt) ::
    console.warn @ 'ENDPOINT MSG:', pkt
  on_warn(ep, msg, extra) ::
    console.warn @ 'ENDPOINT WARN:', msg
  on_error(ep, err, extra) ::
    console.error @ 'ENDPOINT ERROR:', err
    // return false to prevent auto-shutdown
  on_shutdown(ep, err, extra) ::
    console.error @ `ENDPOINT SHUTDOWN: ${err.message}`


export default endpoint_plugin
export function endpoint_plugin(plugin_options) ::
  plugin_options = Object.assign @ {}, default_plugin_options, plugin_options

  const fallback = @{} __proto__: null
    on_msg: plugin_options.on_msg
    on_error: plugin_options.on_error
    on_shutdown: plugin_options.on_shutdown

  return function(hub) ::
    const random = hub.data_utils.random

    const pi_endpoint = endpoint.bind(null)
    Object.assign @ pi_endpoint, @{}
      endpoint, create, newTargetId
      tgt_router: hub.local
      ep_msgs: Object.create(hub.msgs)

    Object.setPrototypeOf @ pi_endpoint, ep_proto
    return hub[plugin_options.plugin_name] = pi_endpoint

    function endpoint(tgt) ::
      const self = this || pi_endpoint
      return self.create @ self.newTargetId(), tgt

    function newTargetId() ::
      return random(6, true)

    function create(id_target, target) ::
      const self = this || pi_endpoint
      const tgt_router = self.tgt_router

      const ep0 = self.ep_msgs.as @: id_target, id_route: tgt_router.id_route
      // capture the _recv_ method
      const _recv_ = ep0._recv_; delete ep0._recv_
      const ep = as_endpoint_api(ep0)

      // use target to extended ep; see abstract.jsy for notes
      const ready = Promise
        .resolve @
          'function' === typeof target ? target(ep, hub)
          : 'function' === typeof target.on_init
            ? _on_init(target, ep, hub)
            : target
        .then @ _after_init

      ::
        const ep_tgt = ep.toJSON()
        return Object.defineProperties @ ep_tgt, @{}
          ready: @{} value: ready.then @ () => ep_tgt


      function _after_init(tgt) ::
        if null == tgt ::
          throw new TypeError @ `Expected endpoint init to return a closure or interface`

        tgt_router.registerTarget @ id_target,
          sink @ _recv_, ep, tgt, fallback

        return tgt.on_ready ? tgt.on_ready(ep, hub) : tgt

async function _on_init(target, ep, hub) ::
  await target.on_init(ep, hub)
  return target
