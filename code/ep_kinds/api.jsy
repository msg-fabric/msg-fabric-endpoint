import {o_create, o_assign} from './_utils'
import ep_proto from './ep_proto.jsy'

ep_proto._add_kind_ @:
  api_bind_rpc
  api(api) :: return this.api_parallel(api)
  api_parallel(api) ::
    return this.endpoint @ function (ep, hub) ::
      const rpc = api_bind_rpc(api, ep, hub)
      return @{} rpc,
        async on_msg({msg, anon}) ::
          await rpc.invoke @ anon, msg.op,
            api_fn => api_fn(msg.kw, msg.ctx)

  api_inorder(api) ::
    return this.endpoint @ function (ep, hub) ::
      const rpc = api_bind_rpc(api, ep, hub)
      return @{} rpc,
        async on_msg({msg, anon}) ::
          await rpc.invoke_gated @ anon, msg.op,
            api_fn => api_fn(msg.kw, msg.ctx)


function api_bind_rpc(api, ep, hub) ::
  const pfx = api.op_prefix || 'rpc_'
  const lookup_op = api.op_lookup
    ? op => api.op_lookup(pfx + op, ep, hub)
    : 'function' === typeof api
    ? op => api(pfx + op, ep, hub)
    : op => ::
        const fn = api[pfx + op]
        return fn ? fn.bind(api) : fn

  return o_create @ rpc_api, @{}
    lookup_op: @{} value: lookup_op
    err_from: @{} value: ep.toJSON()


const rpc_api = @{}
  async invoke(reply, op, cb) ::
    const api_fn = await this.resolve_op @ reply, op
    if undefined === api_fn :: return

    const res = this.answer @ reply, api_fn, cb
    return await res

  async invoke_gated(reply, op, cb) ::
    const api_fn = await this.resolve_op @ reply, op
    if undefined === api_fn :: return

    const res = Promise.resolve(this.gate)
      .then @ () => this.answer @ reply, api_fn, cb
    this.gate = res.then(noop, noop)
    return await res

  async resolve_op(reply, op) ::
    if 'string' !== typeof op ::
      await reply.send @: op, err_from: this.err_from
        error: @{} message: 'Invalid operation', code: 400
      return

    try ::
      const api_fn = await this.lookup_op(op)
      if ! api_fn ::
        await reply.send @: op, err_from: this.err_from
          error: @{} message: 'Unknown operation', code: 404
      return api_fn
    catch err ::
      await reply.send @: op, err_from: this.err_from
        error: @{} message: `Invalid operation: ${err.message}`, code: 500

  async answer(reply, api_fn, cb) ::
    try ::
      var answer = cb ? await cb(api_fn) : await api_fn()
    catch err ::
      await reply.send @: err_from: this.err_from, error: err
      return false

    if reply.replyExpected ::
      await reply.send @: answer
    return true


function noop() {}

