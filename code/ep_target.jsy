export default class EPTarget ::
  static subclass(extensions) ::
    class EPTarget extends this ::
    Object.assign @ EPTarget.prototype, extensions
    return EPTarget

  constructor(id, msg_ctx, msg_info) ::
    const props = @{}
      id_router: @{} enumerable: true, value: id.id_router
      id_target: @{} enumerable: true, value: id.id_target
      encode: @{} value: simple => this.ep_encode(id, simple)

    if msg_ctx ::
      bindCtxProps @ props, msg_info, () =>
        msg_ctx.to(this, msg_info).fast_json
    return Object.defineProperties @ this, props


  valueOf() :: return this.id_target
  inspect() :: return `«EPTarget ${this.encode(true)}»`
  toJSON() :: return this.encode(false)
  isEPTarget() :: return true

  static json_as_sender(msg_ctx) ::
    return info =>
      this.from_json @ info.from_id, msg_ctx, info

  static from_json(id, msg_ctx, msg_info) ::
    if id :: return new this(id, msg_ctx, msg_info)

  static jsonUnpack(msg_ctx, xformByKey) ::
    xformByKey = Object.create(xformByKey || null)
    xformByKey[this.token] = v =>
      this.from_json @ this.ep_decode(v), msg_ctx
    return this.jsonUnpackByKey(xformByKey)

  static jsonUnpackByKey(xformByKey) ::
    const reg = new WeakMap()
    return sz => JSON.parse @ sz, reviver

    function reviver(key, value) ::
      const xfn = xformByKey[key]
      if undefined !== xfn ::
        reg.set(this, xfn)
        return value

      if 'object' === typeof value ::
        const vfn = reg.get(value)
        if undefined !== vfn ::
          return vfn @ value
      return value


function bindCtxProps(props, msg_info, init) ::
  let ctx
  props.send = @{} get() :: return (ctx || (ctx = init())).send
  props.query = @{} get() :: return (ctx || (ctx = init())).query
  if msg_info && msg_info.msgid ::
    // reads as "sender.replyExpected"
    props.replyExpected = @{} value: true


const token = '\u03E0' // 'Ϡ'
EPTarget.token = token

EPTarget.ep_encode = EPTarget.prototype.ep_encode = ep_encode
export function ep_encode(id, simple) ::
  let {id_router:r, id_target:t} = id
  r = (r>>>0).toString(36)
  t = (t>>>0).toString(36)
  if simple ::
    return `${token} ${r}~${t}`

  const res = @{} [token]: `${r}~${t}`
  Object.assign @ res, id
  delete res.id_router; delete res.id_target
  return res


EPTarget.ep_decode = EPTarget.prototype.ep_decode = ep_decode
export function ep_decode(v) ::
  const id = 'string' === typeof v
    ? v.split(token)[1]
    : v[token]
  if ! id :: return

  let [r,t] = id.split('~')
  if undefined === t :: return
  r = 0 | parseInt(r, 36)
  t = 0 | parseInt(t, 36)

  return @{} id_router: r, id_target: t

