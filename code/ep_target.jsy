export default EPTarget
export class EPTarget ::
  constructor(id) :: this.id = id

  static from_ready(id, ready) ::
    const ep_tgt = new this(id)
    return Object.defineProperties @ ep_tgt, @{}
      ready: @{} value: ready.then @ () => ep_tgt

  valueOf() :: return this.id.id_target
  inspect() :: return `«EPTarget ${ep_encode(this.id, true)}»`
  toJSON() :: return ep_encode(this.id, false)
  isEPTarget() :: return true

  get id_router() :: return this.id.id_router
  get id_target() :: return this.id.id_target


function bindCtxProps(ep_tgt, msg_ctx_to, msgid) ::
  let ctx, init = () => ctx = msg_ctx_to(ep_tgt, {msgid}).fast_json
  return Object.defineProperties @ ep_tgt, @{}
    send: @{} get() :: return (ctx || init()).send
    query: @{} get() :: return (ctx || init()).query
    replyExpected: @{} value: !! msgid


const token = '\u03E0' // 'Ϡ'
EPTarget.token = token

export function ep_encode(id, simple) ::
  let {id_router:r, id_target:t} = id
  r = (r>>>0).toString(36)
  t = (t>>>0).toString(36)
  if simple ::
    return `${token} ${r}~${t}`

  const res = @{} [token]: `${r}~${t}`
  Object.assign @ res, id
  delete res.id_router; delete res.id_target
  return res


export function ep_decode(v) ::
  const id = 'string' === typeof v
    ? v.split(token)[1]
    : v[token]
  if ! id :: return

  let [r,t] = id.split('~')
  if undefined === t :: return
  r = 0 | parseInt(r, 36)
  t = 0 | parseInt(t, 36)

  return @{} id_router: r, id_target: t


export function ep_target(id, msg_ctx_to, msgid) ::
  if id :: return bindCtxProps @ new EPTarget(id), msg_ctx_to, msgid

export function ep_json_unpack(msg_ctx_to, xformByKey) ::
  xformByKey = Object.create(xformByKey || null)
  xformByKey[token] = v =>
    ep_target @ ep_decode(v), msg_ctx_to
  return json_unpack_xform(xformByKey)

export function json_unpack_xform(xformByKey) ::
  return sz => JSON.parse @ sz, reviver()

  function reviver() ::
    const reg = new WeakMap()
    return function(key, value) ::
      const xfn = xformByKey[key]
      if undefined !== xfn ::
        reg.set(this, xfn)
        return value

      if 'object' === typeof value ::
        const vfn = reg.get(value)
        if undefined !== vfn ::
          return vfn @ value
      return value

