export default EPTarget
export class EPTarget ::
  constructor(id) :: this.id = id

  inspect() :: return `«EPTarget ${ep_encode(this.id, true)}»`
  toJSON() :: return ep_encode(this.id, false)
  asEndpointId() :: return this.id
  isEPTarget() :: return true

  get id_router() :: return this.id.id_router
  get id_target() :: return this.id.id_target

  static as_json_unpack(msg_ctx_to, xformByKey) ::
    xformByKey = Object.create(xformByKey || null)
    xformByKey[token] = v => this.from_ctx @ ep_decode(v, true), msg_ctx_to
    return this.json_unpack_xform(xformByKey)

  static from_ctx(id, msg_ctx_to, msgid) ::
    if ! id :: return
    if 'function' === typeof id.asEndpointId ::
      id = id.asEndpointId()

    const ep_tgt = new this(id)
    let fast, init = () => fast = msg_ctx_to(ep_tgt, {msgid}).fast
    return Object.defineProperties @ ep_tgt, @{}
      send: @{} get() :: return (fast || init()).send
      query: @{} get() :: return (fast || init()).query
      replyExpected: @{} value: !! msgid


const token = '\u03E0' // 'Ϡ'
EPTarget.token = token

EPTarget.ep_encode = ep_encode
export function ep_encode(id, simple) ::
  let {id_router:r, id_target:t} = id
  r = (r>>>0).toString(36)
  t = (t>>>0).toString(36)
  if simple ::
    return `${token} ${r}~${t}`

  const res = @{} [token]: `${r}~${t}`
  Object.assign @ res, id
  delete res.id_router; delete res.id_target
  return res


EPTarget.ep_decode = ep_decode
export function ep_decode(v, inc_extra) ::
  const sz_id = 'string' === typeof v
    ? v.split(token)[1]
    : v[token]
  if ! sz_id :: return

  let [r,t] = sz_id.split('~')
  if undefined === t :: return
  r = 0 | parseInt(r, 36)
  t = 0 | parseInt(t, 36)

  const id = @{} id_router: r, id_target: t
  if inc_extra && 'object' === typeof v ::
    Object.assign @ id, v
    delete id[token]
  return id


EPTarget.json_unpack_xform = json_unpack_xform
export function json_unpack_xform(xformByKey) ::
  return sz => JSON.parse @ sz, reviver()

  function reviver() ::
    const reg = new WeakMap()
    return function(key, value) ::
      const xfn = xformByKey[key]
      if undefined !== xfn ::
        reg.set(this, xfn)
        return value

      if 'object' === typeof value ::
        const vfn = reg.get(value)
        if undefined !== vfn ::
          return vfn @ value
      return value

