import framings from './framing.jsy'

export default function(packetParser) ::
  const {concatBuffers, pack_utf8, unpack_utf8} = packetParser

  return @: bindTransports
    trailerAsJSON, trailerAsBuffer
    createMultipart

  function trailerAsJSON(pkt) ::
    const trailer = unpack_utf8 @ pkt.trailer
    pkt.trailer = JSON.parse @ trailer

  function trailerAsBuffer(pkt_obj) ::
    pkt_obj.trailer = pack_utf8 @
      JSON.stringify @ pkt_obj.trailer

  function createMultipart(msgid, sink) ::
    let parts = [], last = false

    return function feed(pkt) ::
      const seq = body.seq
      if seq < 0 :: last = true; seq = -seq
      parts[seq-1] = pkt.body_buffer()

      if ! last :: return
      if parts.includes @ undefined :: return

      const res = concatBuffers(parts)
      parts = null
      return res

  function createStreaming(msgid, sink) ::
    let next=1, last = false

    return function feed(pkt, as_content) ::
      const seq = body.seq
      if seq < 0 :: last = true; seq = -seq
      if next == seq ::
        next++
      else if next !== 'invalid' ::
        next = 'invalid'
        const err = new Error @ `Packet out of sequence`
        return callback @ err, {pkt}
      else return

      let body
      try ::
        body = undefined !== as_content
          ? as_content(pkt) : body.body_buffer()
      catch err ::
        return callback @ err, {pkt}

      return callback @ null, {body, pkt}

  function bindTransports(protocols, highbits, transports) ::
    const packTrailer = transports.packTrailer || trailerAsBuffer
    const unpackTrailer = transports.unpackTrailer || trailerAsJSON
    const local = @:
      inbound: []
      outbound: []
    local.inbound.choose = framings.choose
    local.outbound.choose = framings.choose
      
    for const frame of framings ::
      if null == frame :: continue
      const impl = transports[frame.transport]
      if ! impl :: continue

      const pkt_type = highbits | frame.bits
      const {send, recv} = impl(frame)

      const outbound = @:
        pkt_type
        send(chan, obj) ::
          frame.pack(pkt_type, obj, packTrailer)
          return send(chan, obj)

      const inbound = @:
        pkt_type
        recv(pkt, sink) ::
          frame.unpack(pkt, unpackTrailer)
          return recv(pkt, sink)

      protocols.outbound[pkt_type] = outbound
      protocols.inbound[pkt_type] = inbound

      local.outbound[frame.bits] = outbound
      local.inbound[frame.bits] = inbound

    return local
