import framings from './framing.jsy'

export default function(packetParser, random_id) ::
  const {asBuffer, concatBuffers, pack_utf8, unpack_utf8} = packetParser

  return @: packetParser, random_id
    trailerAsJSON, trailerAsBuffer
    createMultipart, createStreaming
    bindTransports

  function trailerAsJSON(pkt) ::
    const trailer = unpack_utf8 @ pkt.trailer
    pkt.trailer = JSON.parse @ trailer

  function trailerAsBuffer(pkt_obj) ::
    pkt_obj.trailer = pack_utf8 @
      JSON.stringify @ pkt_obj.trailer

  function createMultipart(msgid, sink) ::
    let parts = [], last = false

    return function feed(pkt) ::
      const seq = body.seq
      if seq < 0 :: last = true; seq = -seq
      parts[seq-1] = pkt.body_buffer()

      if ! last :: return
      if parts.includes @ undefined :: return

      const res = concatBuffers(parts)
      parts = null
      return res

  function createStreaming(msgid, sink) ::
    let next=1, last = false

    return function feed(pkt, as_content) ::
      const seq = body.seq
      if seq < 0 :: last = true; seq = -seq
      if next == seq ::
        next++
      else if next !== 'invalid' ::
        next = 'invalid'
        const err = new Error @ `Packet out of sequence`
        return callback @ err, {pkt}
      else return

      let body
      try ::
        body = undefined !== as_content
          ? as_content(pkt) : body.body_buffer()
      catch err ::
        return callback @ err, {pkt}

      return callback @ null, {body, pkt}

  function bindTransports(inbound, highbits, transports) ::
    const packTrailer = transports.packTrailer || trailerAsBuffer
    const unpackTrailer = transports.unpackTrailer || trailerAsJSON
    const packBody = transports.packBody || asBuffer
    const outbound = []
    outbound.choose = framings.choose

    for const frame of framings ::
      const impl = frame ? transports[frame.transport] : null
      if impl ::
        _bind_frame_impl @ frame, impl

    return @: outbound
      send(chan, obj, body) ::
        obj.body = packBody(body)
        const send = outbound.choose(obj)
        return send @ chan, obj

      stream(chan, obj) ::
        obj.transport = 'streaming'
        const stream = outbound.choose(obj)
        return stream @ chan, obj


    function _bind_frame_impl(frame, impl) ::
      const pkt_type = highbits | frame.bits
      const {t_send, t_recv} = impl

      function send(chan, obj) ::
        frame.pack(pkt_type, obj, packTrailer)
        return t_send(chan, obj)

      function recv(pkt, sink) ::
        frame.unpack(pkt, unpackTrailer)
        return t_recv(pkt, sink)

      send.pkt_type = recv.pkt_type = pkt_type
      outbound[frame.bits] = send
      inbound[pkt_type] = recv

      if 'production' !== process.env.NODE_ENV ::
        const op = send.op = recv.op = frame.op
        Object.defineProperty @ send, 'name', @{} value: `send «${op}»`
        Object.defineProperty @ recv, 'name', @{} value: `recv «${op}»`

