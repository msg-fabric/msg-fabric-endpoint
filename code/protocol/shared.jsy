import framings from './framing.jsy'

export default function(packetParser) ::
  const {concatBuffers, pack_utf8, unpack_utf8} = packetParser

  return @: bindTransports
    trailerAsJSON, trailerAsBuffer
    createMultipart

  function trailerAsJSON(pkt) ::
    const trailer = unpack_utf8 @ pkt.trailer
    pkt.trailer = JSON.parse @ trailer

  function trailerAsBuffer(pkt_obj) ::
    pkt_obj.trailer = pack_utf8 @
      JSON.stringify @ pkt_obj.trailer

  function createMultipart(msgid, sink) ::
    let parts = [], last = false

    return function feed(seq, body_buf) ::
      if seq < 0 :: last = true; seq = -seq
      parts[seq-1] = body_buf

      if ! parts.includes @ undefined ::
        const res = concatBuffers(parts)
        parts = null
        return res

  function bindTransports(protocols, highbits, transports) ::
    const packTrailer = transports.packTrailer || trailerAsBuffer
    const unpackTrailer = transports.unpackTrailer || trailerAsJSON
    const local = @:
      inbound: []
      outbound: []
    local.inbound.choose = framings.choose
    local.outbound.choose = framings.choose
      
    for const frame of framings ::
      if null == frame :: continue
      const impl = transports[frame.transport]
      if ! impl :: continue

      const pkt_type = highbits | frame.bits
      const {send, recv} = impl(frame)

      const outbound = @:
        pkt_type
        send(chan, obj) ::
          frame.pack(pkt_type, obj, packTrailer)
          return send(chan, obj)

      const inbound = @:
        pkt_type
        recv(pkt, sink) ::
          frame.unpack(pkt, unpackTrailer)
          return recv(pkt, sink)

      protocols.outbound[pkt_type] = outbound
      protocols.inbound[pkt_type] = inbound

      local.outbound[frame.bits] = outbound
      local.inbound[frame.bits] = inbound

    return local
