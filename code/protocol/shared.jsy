import framings from './framing.jsy'

export default function(packetParser, options, fragment_size) ::
  const {concatBuffers, packPacketObj, pack_utf8, unpack_utf8} = packetParser
  fragment_size = Number(fragment_size || 8000)
  if 1024 > fragment_size || 65000 < fragment_size ::
    throw new Error @ `Invalid fragment size: ${fragment_size}`

  const {random_id, json_reviver, json_replacer} = options
  return @: packetParser, random_id, json_parse, json_stringify
    createMultipart, createStream, packetFragments
    bindTransports


  function json_parse(text) ::
    return JSON.parse @ text, json_reviver
  function json_stringify(obj) ::
    return JSON.stringify @ obj, json_replacer


  function createMultipart(pkt, sink, msgid) ::
    let parts = [], fin = false
    return @{} feed, info: pkt.info

    function feed(pkt) ::
      let seq = pkt.info.seq
      if seq < 0 :: fin = true; seq = -seq
      parts[seq-1] = pkt.body_buffer()

      if ! fin :: return
      if parts.includes @ undefined :: return

      sink.deleteStateFor(msgid)

      const res = concatBuffers(parts)
      parts = null
      return res

  function createStream(pkt, sink, msgid) ::
    let next=0, fin = false, recvData, rstream
    const state = @{} feed: feed_init, info: pkt.info
    return state

    function feed_init(pkt, as_content) ::
      state.feed = feed_ignore

      const info = pkt.info
      const msg = json_parse @ pkt.body_utf8()
      rstream = sink.recvStream(msg, info)
      if null == rstream :: return
      check_fns @ rstream, 'on_error', 'on_data', 'on_end' 
      recvData = sink.recvStreamData.bind(sink, rstream, info)

      try ::
        feed_seq(pkt)
      catch err ::
        return rstream.on_error @ err, pkt

      state.feed = feed_body
      if rstream.on_init ::
        return rstream.on_init(msg, pkt)

    function feed_body(pkt, as_content) ::
      recvData()
      let data
      try ::
        feed_seq(pkt)
        data = as_content(pkt)
      catch err ::
        return rstream.on_error @ err, pkt

      if fin ::
        const res = rstream.on_data @ data, pkt
        return rstream.on_end @ res, pkt
      else ::
        return rstream.on_data @ data, pkt

    function feed_ignore(pkt) ::
      try :: feed_seq(pkt)
      catch err ::

    function feed_seq(pkt) ::
      let seq = pkt.info.seq
      if seq >= 0 ::
        if next++ === seq ::
          return // in order
      else ::
        fin = true
        sink.deleteStateFor(msgid)
        if next === -seq ::
          next = 'done'
          return // in-order, last packet

      state.feed = feed_ignore
      next = 'invalid'
      throw new Error @ `Packet out of sequence`

  function * packetFragments(buf, next_hdr, fin) ::
    if null == buf ::
      const obj = next_hdr({fin})
      yield obj
      return

    let i = 0, lastInner = buf.byteLength - fragment_size;
    while i < lastInner ::
      const i0 = i
      i += fragment_size

      const obj = next_hdr()
      obj.body = buf.slice(i0, i)
      yield obj

    ::
      const obj = next_hdr({fin})
      obj.body = buf.slice(i)
      yield obj



  function bindTransportImpls(inbound, highbits, transports) ::
    const outbound = []
    outbound.choose = framings.choose

    for const frame of framings ::
      const impl = frame ? transports[frame.transport] : null
      if ! impl :: continue

      const {bits, pack, unpack} = frame
      const pkt_type = highbits | bits
      const {t_recv} = impl

      function pack_hdr(obj) ::
        pack(pkt_type, obj)
        return obj

      function recv_msg(pkt, sink) ::
        unpack(pkt)
        return t_recv(pkt, sink)

      pack_hdr.pkt_type = recv_msg.pkt_type = pkt_type
      outbound[bits] = pack_hdr
      inbound[pkt_type] = recv_msg

      if 'production' !== process.env.NODE_ENV ::
        const op = pack_hdr.op = recv_msg.op = frame.op
        Object.defineProperty @ pack_hdr, 'name', @{} value: `pack_hdr «${op}»`
        Object.defineProperty @ recv_msg, 'name', @{} value: `recv_msg «${op}»`

    return outbound


  function bindTransports(inbound, highbits, transports) ::
    const packBody = transports.packBody
    const packStream = transports.packStream
    const outbound = bindTransportImpls(inbound, highbits, transports)
    return transports.streaming
      ? @{} send, stream: bind_stream @ transports.streaming.mode
      : @{} send

    function send(chan, obj, body) ::
      body = packBody(body)
      if fragment_size < body.byteLength ::
        if ! obj.token :: obj.token = random_id()
        obj.transport = 'multipart'
        const msend = msend_bytes(chan, obj)
        return @{} sent: msend @ true, body

      obj.transport = 'single'
      obj.body = body
      const pack_hdr = outbound.choose(obj)
      const pkt = packPacketObj @ pack_hdr(obj)
      return @{} sent: chan @ pkt

    function msend_bytes(chan, obj, msg) ::
      const pack_hdr = outbound.choose(obj)
      let {next} = pack_hdr(obj)
      if null !== msg ::
        obj.body = msg
        const pkt = packPacketObj @ obj
        chan @ pkt

      return async function (fin, body) ::
        if null === next ::
          throw new Error @ 'Write after end'
        let res
        for const obj of packetFragments @ body, next, fin ::
          const pkt = packPacketObj @ obj
          res = await chan @ pkt
        if fin :: next = null
        return res

    function msend_objects(chan, obj, msg) ::
      const pack_hdr = outbound.choose(obj)
      let {next} = pack_hdr(obj)
      if null !== msg ::
        obj.body = msg
        const pkt = packPacketObj @ obj
        chan @ pkt

      return function (fin, body) ::
        if null === next ::
          throw new Error @ 'Write after end'
        const obj = next({fin})
        obj.body = body
        const pkt = packPacketObj @ obj
        if fin :: next = null
        return chan @ pkt

    function bind_stream(mode) ::
      const msend_impl = {object: msend_objects, bytes: msend_bytes}[mode]
      if msend_impl :: return stream

      function stream(chan, obj, msg) ::
        if ! obj.token :: obj.token = random_id()
        obj.transport = 'streaming'
        const msend = msend_impl @ chan, obj, json_stringify(msg)
        write.write = write; write.end = write.bind(true)
        return write

        function write(chunk) ::
          return chunk != null
            ? msend @ true===this, packBody @ chunk
            : msend @ true


function check_fns(obj, ...keys) ::
  for const key of keys ::
    if 'function' !== typeof obj[key] ::
      throw new TypeError @ `Expected "${key}" to be a function`
