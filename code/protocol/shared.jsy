import framings from './framing.jsy'

export default function(packetParser, random_id, fragment_size) ::
  const {concatBuffers, packPacketObj, pack_utf8, unpack_utf8} = packetParser
  fragment_size = Number(fragment_size || 8000)
  if 1024 > fragment_size || 65000 < fragment_size ::
    throw new Error @ `Invalid fragment size: ${fragment_size}`

  return @: packetParser, random_id
    createMultipart, createStream, packetFragments
    bindTransports



  function createMultipart(pkt, sink) ::
    let parts = [], fin = false
    return @{} feed, info: pkt.info

    function feed(pkt) ::
      let seq = pkt.info.seq
      if seq < 0 :: fin = true; seq = -seq
      parts[seq-1] = pkt.body_buffer()

      if ! fin :: return
      if parts.includes @ undefined :: return

      const res = concatBuffers(parts)
      parts = null
      return res

  function createStream(pkt, sink) ::
    let next=0, fin = false, rstream
    const state = @{} feed: feed_init, info: pkt.info
    return state

    function on_error(err, pkt) ::
      if undefined === rstream.on_error ::
        return void console.warn @
          `Error during stream.feed:`, err
      return rstream.on_error @ err, pkt

    function feed_init(pkt, as_content) ::
      state.feed = feed_ignore

      const msg = pkt.body_json()
      rstream = sink.recvStream(msg, pkt.info)
      if null == rstream :: return

      try ::
        if ! feed_seq(pkt) :: return
        state.feed = feed_body
      catch err ::
        return on_error @ err, pkt

      if 'function' === typeof rstream.on_init ::
        return rstream.on_init(msg, pkt)
      else return sink.recvMsg @ msg, pkt.info
    
    function feed_body(pkt, as_content) ::
      let data
      try ::
        if ! feed_seq(pkt) :: return
        data = as_content(pkt)
      catch err ::
        return on_error @ err, pkt
      return rstream.on_data @ data, pkt

    function feed_ignore() ::

    function feed_seq(pkt) ::
      let seq = pkt.info.seq
      if seq < 0 :: fin = true; seq = -seq
      if next === seq :: return ++next
      state.feed = feed_ignore
      next = 'invalid'
      throw new Error @ `Packet out of sequence`

  function * packetFragments(buf, next_hdr, fin) ::
    if null == buf ::
      const obj = next_hdr({fin})
      yield obj
      return

    let i = 0, lastInner = buf.byteLength - fragment_size;
    while i < lastInner ::
      const i0 = i
      i += fragment_size

      const obj = next_hdr()
      obj.body = buf.slice(i0, i)
      yield obj

    ::
      const obj = next_hdr({fin})
      obj.body = buf.slice(i)
      yield obj



  function bindTransportImpls(inbound, highbits, transports) ::
    const outbound = []
    outbound.choose = framings.choose

    for const frame of framings ::
      const impl = frame ? transports[frame.transport] : null
      if ! impl :: continue

      const {bits, pack, unpack} = frame
      const pkt_type = highbits | bits
      const {t_recv} = impl

      function pack_hdr(obj) ::
        pack(pkt_type, obj)
        return obj

      function recv_msg(pkt, sink) ::
        unpack(pkt)
        return t_recv(pkt, sink)

      pack_hdr.pkt_type = recv_msg.pkt_type = pkt_type
      outbound[bits] = pack_hdr
      inbound[pkt_type] = recv_msg

      if 'production' !== process.env.NODE_ENV ::
        const op = pack_hdr.op = recv_msg.op = frame.op
        Object.defineProperty @ pack_hdr, 'name', @{} value: `pack_hdr «${op}»`
        Object.defineProperty @ recv_msg, 'name', @{} value: `recv_msg «${op}»`

    return outbound


  function bindTransports(inbound, highbits, transports) ::
    const packBody = transports.packBody
    const packStream = transports.packStream
    const outbound = bindTransportImpls(inbound, highbits, transports)
    const stream = ! transports.streaming ? null :
      'object' === transports.streaming.mode
        ? bind_stream @ msend_objects
        : bind_stream @ msend_bytes

    return @{} send, stream

    function send(chan, obj, body) ::
      body = packBody(body)
      if fragment_size < body.byteLength ::
        if ! obj.token :: obj.token = random_id()
        const msend = msend_bytes('multipart', chan, obj)
        return @{} sent: msend @ true, body

      obj.transport = 'single'
      obj.body = body
      const pack_hdr = outbound.choose(obj)
      const pkt = packPacketObj @ pack_hdr(obj)
      return @{} sent: chan @ pkt

    function msend_bytes(transport, chan, obj, msg) ::
      obj.transport = transport
      const pack_hdr = outbound.choose(obj)
      let {next} = pack_hdr(obj)
      if null !== msg ::
        obj.body = msg
        const pkt = packPacketObj @ obj
        chan @ pkt

      return async function (fin, body) ::
        if null === next ::
          throw new Error @ 'Write after end'
        let res
        for const obj of packetFragments @ body, next, fin ::
          const pkt = packPacketObj @ obj
          res = await chan @ pkt
        if fin :: next = null
        return res

    function msend_objects(transport, chan, obj, msg) ::
      obj.transport = transport
      const pack_hdr = outbound.choose(obj)
      let {next} = pack_hdr(obj)
      if null !== msg ::
        obj.body = msg
        const pkt = packPacketObj @ obj
        chan @ pkt

      return function (fin, body) ::
        if null === next ::
          throw new Error @ 'Write after end'
        const obj = next({fin})
        obj.body = body
        const pkt = packPacketObj @ obj
        if fin :: next = null
        return chan @ pkt

    function bind_stream(send_impl) ::
      return function stream (chan, obj, msg) ::
        if ! obj.token :: obj.token = random_id()
        if 'object' !== typeof msg ::
          throw new TypeError @ `stream() requires a JSON seralizable msg for initial packet`
        msg = JSON.stringify(msg)
        const msend = send_impl('streaming', chan, obj, msg)
        write.write = write; write.end = end
        return write

        function write(chunk) ::
          return chunk != null
            ? msend @ false, packBody @ chunk
            : msend @ true

        function end(chunk) ::
          return chunk != null
            ? msend @ true, packBody @ chunk
            : msend @ true
