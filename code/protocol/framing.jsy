const little_endian = true
const c_single = 'single'
const c_datagram = 'datagram'
const c_direct = 'direct'
const c_multipart = 'multipart'
const c_streaming = 'streaming'

const _err_msgid_required = `Response reqires 'msgid'`
const _err_token_required = `Transport reqires 'token'`

function pack_routing(obj, dv, offset) ::
  dv.setInt32 @ 0+offset, 0|obj.id_router, little_endian
  dv.setInt32 @ 4+offset, 0|obj.id_target, little_endian

function unpack_routing(obj, dv, offset) ::
  obj.id_router = dv.getInt32 @ 0+offset, little_endian
  obj.id_target = dv.getInt32 @ 4+offset, little_endian


export const basic_framings = @:
  from_routing: @:
    size: 8, bits: 0x1, mask: 0x1
    f_test(obj) :: return null != obj.from_id

    f_pack(obj, dv, offset) ::
      pack_routing(obj.from_id, dv, offset)

    f_unpack(obj, dv, offset) ::
      if undefined === obj.from_id ::
        obj.from_id = {}
      unpack_routing(obj.from_id, dv, offset)

  response: @:
    size: 6, bits: 0x2, mask: 0x2
    f_test(obj) :: return null != obj.msgid

    f_pack(obj, dv, offset) ::
      if ! obj.msgid :: throw new Error @ _err_msgid_required
      dv.setInt32 @ 0+offset, obj.msgid, little_endian
      dv.setInt16 @ 4+offset, 0|obj.seq_ack, little_endian

    f_unpack(obj, dv, offset) ::
      obj.token = dv.getInt32 @ 0+offset, little_endian
      obj.seq_ack = dv.getInt16 @ 4+offset, little_endian

  datagram: @:
    size: 0, bits: 0x0, mask: 0xc
    transport: c_datagram
    f_test(obj) ::
      if c_datagram === obj.transport :: return true
      if obj.transport && c_single !== obj.transport :: return false
      return ! obj.token
    f_pack(obj, dv, offset) ::
    f_unpack(obj, dv, offset) ::
      obj.transport = c_datagram

  direct: @:
    size: 4, bits: 0x4, mask: 0xc
    transport: c_direct
    f_test(obj) ::
      if c_direct === obj.transport :: return true
      if obj.transport && c_single !== obj.transport :: return false
      return !! obj.token
    f_pack(obj, dv, offset) ::
      if ! obj.token :: throw new Error @ _err_token_required
      dv.setInt32 @ 0+offset, obj.token, little_endian
    f_unpack(obj, dv, offset) ::
      obj.msgid = dv.getInt32 @ 0+offset, little_endian
      obj.transport = c_direct

  multipart: @:
    size: 6, bits: 0x8, mask: 0xc
    transport: c_multipart
    f_test(obj) ::
      return c_multipart === obj.transport

    bind_seq_next, seq_pos: 4
    f_pack(obj, dv, offset) ::
      if ! obj.token :: throw new Error @ _err_token_required
      dv.setInt32 @ 0+offset, obj.token, little_endian
      dv.setInt16 @ 4+offset, obj.seq || 1

    f_unpack(obj, dv, offset) ::
      obj.msgid     = dv.getInt32 @ 0+offset, little_endian
      obj.seq       = dv.getInt16 @ 4+offset
      obj.transport = c_multipart

  streaming: @:
    size: 6, bits: 0xc, mask: 0xc
    transport: c_streaming
    f_test(obj) ::
      return c_streaming === obj.transport

    bind_seq_next, seq_pos: 4
    f_pack(obj, dv, offset) ::
      if ! obj.token :: throw new Error @ _err_token_required
      dv.setInt32 @ 0+offset, obj.token, little_endian
      dv.setInt16 @ 4+offset, obj.seq||1

    f_unpack(obj, dv, offset) ::
      obj.msgid = dv.getInt32 @ 0+offset, little_endian
      obj.seq   = dv.getInt16 @ 4+offset, little_endian
      obj.transport = c_streaming


function bind_seq_next(offset, seq_pos) ::
  const seq_offset = seq_pos + offset
  seq_next.seq_offset = seq_offset
  let seq = 2
  return seq_next

  function seq_next({flags, done}, dv) ::
    if ! done ::
      dv.setInt16 @ seq_offset, seq++, little_endian
      dv.setInt16 @ 2+seq_offset, 0|flags, little_endian
    else ::
      dv.setInt16 @ seq_offset, -seq, little_endian
      dv.setInt16 @ 2+seq_offset, 0|flags, little_endian
      seq = NaN

export const framings = composeFramings()
export default framings

function composeFramings() ::
  for const [name, f] of Object.entries(basic_framings) ::
    const {size, bits} = f, info = {size, bits}
    if 'production' !== process.env.NODE_ENV ::
      const op = `${name}[${f.size}]`
      f.op = info.op = op
      if f.f_pack ::
        Object.assign @ f.f_pack, info
        Object.defineProperty @ f.f_pack, 'name', @{} value: `f_pack «${op}»`
      if f.f_unpack ::
        Object.assign @ f.f_unpack, info
        Object.defineProperty @ f.f_unpack, 'name', @{} value: `f_unpack «${op}»`
      if f.f_test ::
        Object.assign @ f.f_test, info
        Object.defineProperty @ f.f_test, 'name', @{} value: `f_test «${op}»`
    else ::
      if f.f_pack :: f.f_pack.size = size
      if f.f_unpack :: f.f_unpack.size = size
      if f.f_test :: f.f_test.bits = bits

  const byBits = []
  for let bits=0; bits <= 0xf; bits++ ::
    const cfn = compose @ bits
    byBits[bits] = cfn

  const framingTests = Object.values(basic_framings).map(f=>f.f_test).filter(f=>f)
  function testBits(obj) ::
    let i = 0
    for const f_test of framingTests ::
      if f_test(obj) :: i |= f_test.bits
    return i

  byBits.testBits = testBits
  byBits.choose = function (obj, lst) ::
    const i = testBits(obj)
    if null == lst :: lst = this || byBits
    return lst[i]

  return byBits

  function fold(r, f, ...args) ::
    const offset = 0|r.size
    fpk2.size = r.size + (0|f.size)
    if 'production' !== process.env.NODE_ENV ::
      fpk2.op = `${r.op}-${f.op}@${offset}`
    return fpk2

    function fpk2(obj, dv) ::
      r(obj, dv, 0)
      f(obj, dv, offset)

  function compose(bits) ::
    const parts = Object.values(basic_framings)
      .filter @ f => f.bits === (bits & f.mask)

    const pack_frames = parts.map(f=>f.f_pack).reduce(fold)
    const unpack_frames = parts.map(f=>f.f_unpack).reduce(fold)
    const {seq_next} = parts.reduce @
      (r, f) => 'function' === typeof r.seq_next ? r
        : f.bind_seq_next
          ? @{} seq_next: f.bind_seq_next(r.size, f.seq_pos)
          : @{} size: r.size + f.size
      , @{} size:0

    const {transport} = parts.find(f=>f.transport)
    const {size, op} = pack_frames

    if 'production' !== process.env.NODE_ENV ::
      Object.defineProperty @ pack, 'name', @{} value: `pack «${op}»`
      Object.defineProperty @ pack_frames, 'name', @{} value: `pack_frames «${op}»`
      Object.defineProperty @ unpack, 'name', @{} value: `unpack «${op}»`
      Object.defineProperty @ unpack_frames, 'name', @{} value: `unpack_frames «${op}»`

    return @:
      bits, mask:0xf, size, op
      transport, parts
      pack, unpack


    function pack(pkt_type, pkt_obj) ::
      if ! @ 0 <= pkt_type && pkt_type <= 255 ::
        throw new TypeError @ `Expected pkt_type to be [0..255]`

      pkt_obj.type = pkt_type
      if seq_next && null == pkt_obj.seq ::
        pkt_obj.seq = true

      const dv = new DataView @ new ArrayBuffer(size)
      pack_frames(pkt_obj, dv)
      pkt_obj.header = dv.buffer

      if true === pkt_obj.seq ::
        _bind_iterable @ pkt_obj, dv.buffer.slice(0,size)

    function unpack(pkt) ::
      const buf = pkt.header_buffer()
      const dv = new DataView @ new Uint8Array(buf).buffer

      const info = {}
      unpack_frames(info, dv)
      return pkt.info = info


    function _bind_iterable(pkt_obj, buf_clone) ::
      const {type} = pkt_obj
      const {id_router, id_target, ttl} = pkt_obj
      pkt_obj.next = next

      function next(options) ::
        const header = buf_clone.slice()
        seq_next @ options, new DataView @ header
        return @: done: false, value: @{} // pkt_obj
          type, ttl, id_router, id_target, header

