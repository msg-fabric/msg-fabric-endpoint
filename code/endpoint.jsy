export default class Endpoint ::
  static forProtocols({MsgCtx}) ::
    class Endpoint extends this ::
    Endpoint.prototype.MsgCtx = MsgCtx
    return Endpoint

  valueOf() :: return this.from_id
  inspect() :: return `«Endpoint ${this.from_id.id_target}»`

  constructor(id_target, hub) ::
    const from_id = Object.freeze @
      null != id_target
        ? @{} id_router: hub.router.id_self, id_target
        : null

    Object.defineProperties @ this, @:
      from_id: @{} value: from_id, enumerable: true
      to: @{} value: message
      _by_token: @{} value: this.createReplyMap()

    const msg_ctx = this.MsgCtx.from @ this, hub.router.resolveRoute
    function message(...args) ::
      return msg_ctx.clone().with @ ...args

  createStateMap() :: return new Map()
  createReplyMap() :: return new Map()

  replyFor(token) ::
    return this._by_token.get(token)

  bindSink(sink) ::
    return @{}
      by_msgid: this.createStateMap()

      recvControl: (msg, info) => ::
        const reply = this.replyFor(info.token)
        const rmsg = this.recvControl(msg, info)
        return undefined === reply
          ? rmsg : reply(rmsg || msg)

      recvMsg: (msg, info) => ::
        const reply = this.replyFor(info.token)
        const rmsg = this.recvMsg(msg, info)
        return undefined === reply
          ? rmsg : reply(rmsg || msg)

      recvStream: info =>
        this.recvStream(info)

  recvControl(msg, info) ::
  recvMsg(msg, info) ::
    return @{} msg, info
  recvStream(info) ::
    console.warn @ `Unhandle recv stream: ${info}`
    //return function (err, content, pkt) ::

  initReply(token, msg_ctx, kind) ::
    return this.initReplyPromise @ token, msg_ctx.ms_timeout

  initReplyPromise(token, ms_timeout) ::
    const ans = new Promise @ (resolve, reject) => ::
      this._by_token.set @ token, resolve
      if ms_timeout ::
        setTimeout(timeout, ms_timeout).unref()
        function timeout() :: reject @ new ReplyTimeout

    return sent => ::
      ans.sent = sent
      return ans

class ReplyTimeout extends Error ::
