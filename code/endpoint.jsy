import {EPTarget, ep_encode} from './ep_target.jsy'

export default class Endpoint ::
  static subclass(extensions) ::
    class Endpoint extends this ::
    Object.assign @ Endpoint.prototype, extensions
    return Endpoint

  valueOf() :: return this.id.id_target
  inspect() :: return `«Endpoint ${ep_encode(this.id, true)}»`
  toJSON() :: return this.asTarget().toJSON()

  constructor(id, msg_ctx) ::
    Object.defineProperties @ this, @{}
      id: @{} value: id
      to: @{} value: msg_ctx.withEndpoint(this).to

  createMap() :: return new Map()
  createStateMap() :: return this.createMap()
  createReplyMap() :: return this.createMap()
  createTrafficMap() :: return this.createMap()
  createRouteCacheMap() :: return this.createMap()

  bindSink(sink) ::
    const by_token = this.createReplyMap()
    const by_traffic = this.createTrafficMap()
    Object.defineProperties @ this, @:
      by_token: @{} value: by_token
      by_traffic: @{} value: by_traffic

    const traffic = (from_id, traffic) => ::
      const ts = Date.now()
      if from_id ::
        const t = by_traffic.get(from_id.id_target)
        if undefined !== t ::
          t.ts = t[`ts_${traffic}`] = ts
      this.recvTraffic(from_id, traffic, ts)

    return @{}
      by_msgid: this.createStateMap()
      json_unpack: this.EPTarget.as_json_unpack(this.to)

      recvCtrl: (msg, info) => ::
        traffic(info.from_id, 'ctrl')
        const reply = by_token.get(info.token)
        const rmsg = this.recvCtrl(msg, info, reply)

        if undefined !== reply ::
          Promise.resolve(rmsg || {msg, info}).then(reply)
        else return rmsg

      recvMsg: (msg, info) => ::
        traffic(info.from_id, 'msg')
        const reply = by_token.get(info.token)
        const rmsg = this.recvMsg(msg, info, reply)

        if undefined !== reply ::
          Promise.resolve(rmsg).then(reply)
        else return rmsg

      recvStreamData: (rstream, info) => ::
        traffic(info.from_id, 'stream')
      recvStream: (msg, info) => ::
        traffic(info.from_id, 'stream')
        const reply = by_token.get(info.token)
        const rstream = this.recvStream(msg, info, reply)

        if undefined !== reply ::
          Promise.resolve(rstream).then(reply)
        return rstream

  asTarget() ::
    return new this.EPTarget @ this.id
  asSender({from_id, msgid}) ::
    if from_id ::
      return this.EPTarget.from_ctx @ from_id, this.to, msgid

  recvTraffic(from_id, traffic, ts) ::
  recvCtrl(msg, info, is_reply) ::
    if is_reply :: return msg
  recvMsg(msg, info, is_reply) ::
    if is_reply :: return msg
    return @{} msg, info, sender: this.asSender(info)
  recvStream(msg, info, is_reply) ::
    console.warn @ `Unhandle recv stream: ${info}`
    return null
    /* return @{} msg, info
         on_init(msg, pkt) :: // return this
         on_data(data, pkt) :: this.parts.push @ data
         on_end(result, pkt) :: this.parts.join(''); // return this
         on_error(err, pkt) :: console.log @ err
    */

  initReply(token, p_sent, msg_ctx) ::
    return this.initReplyPromise @ token, p_sent, msg_ctx

  initMonitor(id_target) ::
    const key = id_target.id_target || id_target
    let monitor = this.by_traffic.get @ key
    if undefined === monitor ::
      monitor = @{} id_target, ts: Date.now()
        td() :: return Date.now() - this.ts
      this.by_traffic.set @ key, monitor
    return monitor

  initReplyPromise(token, p_sent, msg_ctx) ::
    let reply = new Promise @ (resolve, reject) => ::
      this.by_token.set @ token, resolve
      p_sent.catch @ reject

    if msg_ctx ::
      reply = msg_ctx.withRejectTimeout(reply)

    const clear = () => this.by_token.delete @ token
    reply.then @ clear, clear
    return reply

Endpoint.prototype.EPTarget = EPTarget
