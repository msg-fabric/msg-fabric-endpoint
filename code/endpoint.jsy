export default class Endpoint ::
  static forProtocols({outbound}) ::
    class Endpoint extends this ::
    Endpoint.prototype.MsgCtx = outbound.MsgCtx
    return Endpoint

  valueOf() :: return this.from_id
  inspect() :: return `«Endpoint ${this.from_id.id_target}»`

  constructor(id_target, hub) ::
    if null != id_target ::
      const id_router = hub.router.id_self
      this.from_id = Object.freeze @: id_router, id_target

    const by_msgid = this.createStateMap()
    const chan = hub.connect_self()
    const msg_ctx = this.MsgCtx.from @ this, chan
    const _by_token = this.createReplyMap()
    Object.defineProperties @ this, @:
      _by_token: @{} value: _by_token
      to: @{} value(...args) ::
        return msg_ctx.clone().with @ ...args

  createStateMap() :: return new Map()
  bindStateMap() :: return this.createStateMap()
  createReplyMap() :: return new Map()
  bindReplyMap() :: return this._by_token

  initReplyToken(token, kind) ::
    return x => x
    return new Promise @ (resolve, reject) => ::
      this._by_token.set @ token, resolve
      setTimeout @ timeout, this._ms_timeout
      function timeout() ::
        () => reject @ new ReplyTimeout

class ReplyTimeout extends Error ::
