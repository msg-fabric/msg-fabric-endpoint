export default class Endpoint ::
  static forProtocols({MsgCtx}) ::
    class Endpoint extends this ::
    Endpoint.prototype.MsgCtx = MsgCtx
    return Endpoint

  valueOf() :: return this.from_id
  inspect() :: return `«Endpoint ${this.from_id.id_target}»`

  constructor(id_target, hub) ::
    const from_id = Object.freeze @
      null != id_target
        ? @{} id_router: hub.router.id_self, id_target
        : null

    Object.defineProperties @ this, @:
      from_id: @{} value: from_id, enumerable: true
      to: @{} value: message
      _by_token: @{} value: this.createReplyMap()

    const msg_ctx = this.MsgCtx.from @ this, hub.router.resolveRoute
    function message(...args) ::
      return msg_ctx.clone().with @ ...args

  createStateMap() :: return new Map()
  bindStateMap() :: return this.createStateMap()
  createReplyMap() :: return new Map()
  bindReplyMap() :: return this._by_token

  initReplyToken(token, kind) ::
    return x => x
    return new Promise @ (resolve, reject) => ::
      this._by_token.set @ token, resolve
      setTimeout @ timeout, this._ms_timeout
      function timeout() ::
        () => reject @ new ReplyTimeout

class ReplyTimeout extends Error ::
