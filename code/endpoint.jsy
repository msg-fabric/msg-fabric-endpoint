export default class Endpoint ::
  static forProtocols({}) ::
    class Endpoint extends this ::
    return Endpoint

  valueOf() :: return this.from_id
  inspect() :: return `«Endpoint ${this.from_id.id_target}»`

  constructor(msg_ctx) ::
    msg_ctx = msg_ctx.withEndpoint(this)

    Object.defineProperties @ this, @:
      _by_token: @{} value: this.createReplyMap()
      _by_traffic: @{} value: this.createTrafficMap()
      from_id: @{} value: msg_ctx.from_id, enumerable: true
      to: @{} value: msg_ctx.to

  createMap() :: return new Map()
  createStateMap() :: return this.createMap()
  createReplyMap() :: return this.createMap()
  createTrafficMap() :: return this.createMap()

  bindSink(sink) ::
    const by_token = this._by_token
    const by_traffic = this._by_traffic
    const traffic = (from_id, traffic) => ::
      const ts = Date.now()
      if from_id ::
        const t = by_traffic.get(from_id.id_target)
        if undefined !== t :: t.ts = ts
      this.recvTraffic(from_id, traffic, ts)

    const {id_target, id_router} = this.from_id
    return @{}
      from_id: this.from_id
      by_msgid: this.createStateMap()

      recvCtrl: (msg, info) => ::
        traffic(info.from_id, 'ctrl')
        const rmsg = this.recvCtrl(msg, info)

        const reply = by_token.get(info.token)
        if undefined !== reply ::
          Promise.resolve({rmsg, msg, info}).then(reply)
        else return rmsg

      recvMsg: (msg, info) => ::
        traffic(info.from_id, 'msg')
        const rmsg = this.recvMsg(msg, info)

        const reply = by_token.get(info.token)
        if undefined !== reply ::
          Promise.resolve({rmsg, msg, info}).then(reply)
        else return rmsg

      recvStream: (msg, info) => ::
        traffic(info.from_id, 'stream')
        const rmsg = this.recvMsg(msg, info)
        const rstream = this.recvStream(msg, info)
        if rstream != null && 'function' !== typeof rstream.on_data ::
          throw new TypeError @ `Expected object with on_data(data, pkt) function`

        const reply = by_token.get(info.token)
        if undefined !== reply ::
          Promise.resolve({rstream, msg, info}).then(reply)
        return rstream

  recvTraffic(from_id, traffic, ts) ::
  recvCtrl(msg, info) ::
  recvMsg(msg, info) ::
    return @{} msg, info
  recvStream(msg, info) ::
    console.warn @ `Unhandle recv stream: ${info}`
    //return @{}
    //  on_data(data, pkt) ::
    //  on_error(err, pkt) ::

  initReply(token, msg_ctx, kind) ::
    return this.initReplyPromise @ token, msg_ctx.ms_timeout

  initMonitor(id_target) ::
    const key = id_target.id_target || id_target
    let monitor = this._by_traffic.get @ key
    if undefined === monitor ::
      monitor = @{} id_target, ts: Date.now()
        td() :: return Date.now() - this.ts
      this._by_traffic.set @ key, monitor
    return monitor

  initReplyPromise(token, ms_timeout) ::
    const ans = new Promise @ (resolve, reject) => ::
      this._by_token.set @ token, resolve
      if ms_timeout ::
        const tid = setTimeout(timeout, ms_timeout)
        if tid.unref :: tid.unref()
        function timeout() :: reject @ new this.ReplyTimeout

    return sent => ::
      ans.sent = sent
      return ans

class ReplyTimeout extends Error ::

Object.assign @ Endpoint.prototype, @{}
  ReplyTimeout
