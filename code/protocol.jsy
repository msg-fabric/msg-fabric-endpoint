import framings from './framing.jsy'

export const basic_protocols = @:
  json(protocols, opts) ::
    const high = 0x00 // 0x0* — JSON header, JSON body; NDJSON streaming 
    const transports = @: direct, multipart, streaming

    for const frame of framings ::
      if null == frame :: continue
      const impl = transports[frame.transport]
      if !impl :: continue
      const {send, recv} = impl(frame, opts)

      const entry = @:
        type: high | frame.bits

        send(chan, obj) ::
          chan.context.header = frame.create(obj, chan.context)
          return send(chan, obj)

        recv(msg, sink) ::
          const dv = frame.load(msg, msg._raw_, trailerAsJSON)
          return recv(msg, sink)

      protocols[entry.type] = entry


    function direct(frame, opts) ::
      return @:
        send(chan, obj) ::
          chan.context.body = JSON.stringify(obj.body)
          return chan.sendRaw @ chan.pack()
        recv(msg, sink) ::
          return msg

    function multipart(frame, opts) ::
      return @:
        send(chan, obj) ::
          throw new Error @ 'TODO: split into packets…'
        recv(msg, sink) ::
          const feed = sink.entryFor @ msg.msgid, createMultipart
          const buf = feed @ msg.seq, msg.body_buffer()
          if undefined !== buf ::
            let body = msg.packetParser.unpack_utf8 @ buf
            body = JSON.parse @ body
            msg.body = body
            return msg

    function streaming(frame, opts) ::
      return @:
        send() :: throw new Error @ 'TODO'
        recv() :: throw new Error @ 'TODO'


  binary(protocols, opts) ::
    const high = 0x10 // 0x1* — JSON header, binary body
    const transports = @: direct, multipart, streaming

    for const frame of framings ::
      if null == frame :: continue
      const impl = transports[frame.transport]
      if !impl :: continue
      const {send, recv} = impl(frame, opts)

      const entry = @:
        type: high | frame.bits

        send(chan, obj) ::
          chan.context.header = frame.create(obj, chan.context)
          return send(chan, obj)

        recv(msg, sink) ::
          const dv = frame.load(msg, msg._raw_, trailerAsJSON)
          return recv(msg, sink)

      protocols[entry.type] = entry


    function direct(frame, opts) ::
      return @:
        send(chan, obj) ::
          return chan.sendRaw @ chan.pack @ obj
        recv(msg, sink) ::
          msg.body = msg.body_buffer()
          return msg

    function multipart(frame, opts) ::
      return @:
        send(chan, obj) ::
          throw new Error @ 'TODO: split into packets…'
        recv(msg, sink) ::
          const feed = sink.entryFor @ msg.msgid, createMultipart
          const buf = feed @ msg.seq, msg.body_buffer()
          if undefined !== buf ::
            msg.body = buf
            return msg

    function streaming(frame, opts) ::
      return @:
        send() :: throw new Error @ 'TODO'
        recv() :: throw new Error @ 'TODO'


export const protocol = []
export default protocol

export function trailerAsJSON(msg) ::
  const trailer = msg.unpack_utf8 @ msg.trailer
  msg.trailer = JSON.parse @ trailer

export function createMultipart(msgid, sink) ::
  const {concatBuffers} = sink.packetParser
  let parts = [], last = false

  return function feed(seq, body_buf) ::
    if seq < 0 :: last = true; seq = -seq
    parts[seq-1] = body_buf

    if ! parts.includes @ undefined ::
      const res = concatBuffers(parts)
      parts = null
      return res

