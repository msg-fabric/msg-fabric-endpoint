export default class Sink ::
  static forProtocols({inbound}) ::
    class Sink extends this ::
    Sink.prototype._protocol = inbound
    return Sink

  register(endpoint, hub, id_target, handlers) ::
    const unregister = () => hub.router.unregisterTarget(id_target)

    hub.router.registerTarget @ id_target,
      this._bindDispatch @ endpoint, unregister, handlers
    return this

  _bindDispatch(endpoint, unregister, {on_msg, on_error, on_shutdown}) ::
    let alive = true
    const protocol = this._protocol
    const isAlive = () => alive
    const shutdown = (err, extra) => ::
      if alive ::
        unregister(); unregister = alive = false
        on_shutdown(err, extra)

    Object.assign @ this, endpoint.bindSink(this), @{} isAlive, shutdown
    Object.assign @ endpoint, @{} isAlive, shutdown

    return async (pkt, router) => ::
      if false===alive || null==pkt :: return alive

      const recv_msg = protocol[pkt.type]
      if undefined === recv_msg ::
        return void on_error @ false, @{} pkt, zone: 'pkt.type'

      try ::
        var msg = await recv_msg @ pkt, this, router
        if ! msg :: return msg
      catch err ::
        return void on_error @ err, @{} pkt, zone: 'protocol'

      if false === alive ::
        return router.unregister

      try ::
        await on_msg @ msg, pkt
      catch err ::
        try ::
          var terminate = on_error @ err, @{} msg, pkt, zone: 'dispatch'
        finally ::
          if false !== terminate ::
            shutdown(err, {msg, pkt})
            return router.unregister

  //// Endpoint bindSink() responsibilities
  // by_msgid: new Map()
  // json_unpack(sz) :: return JSON.parse(sz)
  // recvCtrl(msg, info) ::
  // recvMsg(msg, info) :: return @{} msg, info
  // recvStream(msg, info) ::
  // recvStreamData(rstream, info) ::

