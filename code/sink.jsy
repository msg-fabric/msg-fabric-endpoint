export default class Sink ::
  static forProtocols({inbound}) ::
    class Sink extends this ::
    Sink.prototype._protocol = inbound
    return Sink

  static register(endpoint, kw_args) ::
    return new this().register(endpoint, kw_args)
  register(endpoint, {hub, id_target, on_msg, on_error}) ::
    hub.router.registerTarget @ id_target,
      this.bindDispatch @ endpoint, on_msg, on_error
    return this

  bindDispatch(endpoint, on_msg, on_error) ::
    const protocol = this._protocol
    Object.assign @ this, endpoint.bindSink(this)
    return async (pkt, router) => ::
      const recv_msg = protocol[pkt.type]
      if undefined === recv_msg ::
        return on_error @ false, @: pkt

      const msg = await recv_msg @ pkt, this, router
      if ! msg :: return msg

      try ::
        return await on_msg @ msg, pkt
      catch err ::
        return on_error @ err, @: msg, pkt

  stateFor(pkt, ifAbsent) ::
    const msgid = pkt.info.msgid
    let entry = this.by_msgid.get(msgid)
    if undefined === entry ::
      if ! msgid ::
        throw new Error @ `Invalid msgid: ${msgid}`
      if 'function' === typeof ifAbsent ::
        entry = ifAbsent(pkt, this)
      else entry = ifAbsent
      this.by_msgid.set @ msgid, entry
    return entry

