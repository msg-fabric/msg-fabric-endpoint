export default class Sink ::
  static forProtocols({inbound}) ::
    class Sink extends this ::
    Sink.prototype._protocol = inbound
    return Sink

  static register(endpoint, kw_args) ::
    return new this().register(endpoint, kw_args)
  register(endpoint, {hub, id_target, on_msg, on_error}) ::
    const unregister = () => ::
      hub.unregisterTarget(id_target) && this.shutdown()

    hub.router.registerTarget @ id_target,
      this._bindDispatch @ endpoint, on_msg, on_error, unregister
    return this

  _bindDispatch(endpoint, on_msg, on_error, unregister) ::
    let alive = true
    const protocol = this._protocol
    const isAlive = () => alive
    const shutdown = () => ::
      if alive :: unregister(); unregister = alive = false

    Object.assign @ this, endpoint.bindSink(this), @{} isAlive, shutdown
    Object.assign @ endpoint, @{} isAlive, shutdown

    return async (pkt, router) => ::
      if false===alive || null==pkt :: return alive

      const recv_msg = protocol[pkt.type]
      if undefined === recv_msg ::
        return on_error @ false, @: pkt

      const msg = await recv_msg @ pkt, this, router
      if ! msg :: return msg

      try ::
        return await on_msg @ msg, pkt
      catch err ::
        return on_error @ err, @: msg, pkt

  stateFor(pkt, ifAbsent) ::
    const msgid = pkt.info.msgid
    let entry = this.by_msgid.get(msgid)
    if undefined === entry ::
      if ! msgid ::
        throw new Error @ `Invalid msgid: ${msgid}`
      if 'function' === typeof ifAbsent ::
        entry = ifAbsent(pkt, this)
      else entry = ifAbsent
      this.by_msgid.set @ msgid, entry
    return entry

