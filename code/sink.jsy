export default class Sink ::
  static forProtocols({inbound}) ::
    class Sink extends this ::
    Sink.prototype._protocol = inbound
    return Sink

  static register(endpoint, kw_args) ::
    return new this().register(endpoint, kw_args)
  register(endpoint, {hub, id_target, on_msg, on_error}) ::
    const unregister = () => hub.router.unregisterTarget(id_target)

    hub.router.registerTarget @ id_target,
      this._bindDispatch @ endpoint, on_msg, on_error, unregister
    return this

  _bindDispatch(endpoint, on_msg, on_error, unregister) ::
    let alive = true
    const protocol = this._protocol
    const isAlive = () => alive
    const shutdown = (err) => ::
      if alive ::
        unregister(); unregister = alive = false
        if err :: console.error @ 'ENDPOINT SHUTDOWN: ' + err

    Object.assign @ this, endpoint.bindSink(this), @{} isAlive, shutdown
    Object.assign @ endpoint, @{} isAlive, shutdown

    return async (pkt, router) => ::
      if false===alive || null==pkt :: return alive

      const recv_msg = protocol[pkt.type]
      if undefined === recv_msg ::
        return on_error @ false, @{} pkt

      try ::
        var msg = await recv_msg @ pkt, this, router
        if ! msg :: return msg
      catch err ::
        return on_error @ err, @{} pkt

      try ::
        return await on_msg @ msg, pkt
      catch err ::
        if false !== on_error(err, {msg, pkt}) ::
          endpoint.shutdown(err, {msg, pkt})

  stateFor(pkt, ifAbsent) ::
    const msgid = pkt.info.msgid
    let entry = this.by_msgid.get(msgid)
    if undefined === entry ::
      if ! msgid ::
        throw new Error @ `Invalid msgid: ${msgid}`
      if 'function' === typeof ifAbsent ::
        entry = ifAbsent(pkt, this, msgid)
      else entry = ifAbsent
      this.by_msgid.set @ msgid, entry
    return entry

  deleteStateFor(msgid) ::
    return this.by_msgid.delete(msgid)
