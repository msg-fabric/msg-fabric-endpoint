export default class Sink ::
  static forProtocols({inbound}) ::
    class Sink extends this ::
    Sink.prototype._protocol = inbound
    return Sink

  static register(endpoint, kw_args) ::
    return new this().register(endpoint, kw_args)
  register(endpoint, {hub, id_target, on_msg, on_error, on_shutdown}) ::
    const unregister = () => hub.router.unregisterTarget(id_target)

    hub.router.registerTarget @ id_target,
      this._bindDispatch @ endpoint, unregister, on_msg, on_error, on_shutdown
    return this

  _bindDispatch(endpoint, unregister, on_msg, on_error, on_shutdown) ::
    let alive = true
    const protocol = this._protocol
    const isAlive = () => alive
    const shutdown = (err, extra) => ::
      if alive ::
        unregister(); unregister = alive = false
        on_shutdown(err, extra)

    Object.assign @ this, endpoint.bindSink(this), @{} isAlive, shutdown
    Object.assign @ endpoint, @{} isAlive, shutdown

    return async (pkt, router) => ::
      if false===alive || null==pkt :: return alive

      const recv_msg = protocol[pkt.type]
      if undefined === recv_msg ::
        return void on_error @ false, @{} pkt, zone: 'pkt.type'

      try ::
        var msg = await recv_msg @ pkt, this, router
        if ! msg :: return msg
      catch err ::
        return void on_error @ err, @{} pkt, zone: 'protocol'

      if false === alive ::
        return false // change while awaiting aboveâ€¦
      try ::
        return await on_msg @ msg, pkt
      catch err ::
        try ::
          var terminate = on_error @ err, @{} msg, pkt, zone: 'dispatch'
        finally ::
          if false !== terminate ::
            shutdown(err, {msg, pkt})
            return false // signal unregister to msg-fabric-core/router

  stateFor(pkt, ifAbsent) ::
    const msgid = pkt.info.msgid
    let entry = this.by_msgid.get(msgid)
    if undefined === entry ::
      if ! msgid ::
        throw new Error @ `Invalid msgid: ${msgid}`
      if 'function' === typeof ifAbsent ::
        entry = ifAbsent(pkt, this, msgid)
      else entry = ifAbsent
      this.by_msgid.set @ msgid, entry
    return entry

  deleteStateFor(msgid) ::
    return this.by_msgid.delete(msgid)
