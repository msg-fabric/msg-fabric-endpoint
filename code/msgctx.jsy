export default class MsgCtx ::
  static forProtocols({random_id, codecs}) ::
    class MsgCtx extends this ::
    MsgCtx.prototype.random_id = random_id
    MsgCtx.withCodecs @ codecs
    return MsgCtx

  constructor(from_id, resolveRoute) ::
    if null !== from_id ::
      const {id_target, id_router} = from_id
      from_id = Object.freeze @: id_target, id_router

    const ctx = {from_id}
    Object.defineProperties @ this, @:
      _root_: @: value: this
      from_id: @: value: from_id
      ctx: @: value: ctx
      resolveRoute: @: value: resolveRoute

  withEndpoint(endpoint) ::
    return Object.defineProperties @ this, @{}
      endpoint: @{} value: endpoint

  static from(id_target, hub) ::
    const from_id = null === id_target ? null
      : @{} id_target, id_router: hub.router.id_self
    return new this @ from_id, hub.router.resolveRoute

  get to() :: return (...args) => this.clone().with @ ...args

  ping(token=true) :: return this.codec('control', {token}).invoke @ 'ping'
  send(...args) :: return this.invoke @ 'send', ...args
  stream(...args) :: return this.invoke @ 'stream', ...args

  invoke(key, ...args) ::
    const obj = Object.assign @ {}, this.ctx
    this.assertMonitor()
    const chan = this.resolveRoute(obj.id_router)
    if true !== obj.token ::
      return this._codec[key] @ chan, obj, ...args

    else ::
      const token = obj.token = this.random_id()
      const reply = this.endpoint.initReply(token, this, key)
      return reply @ this._codec[key] @ chan, obj, ...args


  with(...args) ::
    const ctx = this.ctx
    for let tgt of args ::
      if 'number' === typeof tgt ::
        ctx.id_target = tgt
        ctx.id_router = ctx.from_id.id_router
        continue

      const {from_id: reply_id, id_target, id_router, token, msgid} = tgt

      if undefined !== id_target ::
        if undefined === id_router ::
          if ! ctx.id_router ::
            // implicitly on the same router
            ctx.id_router = ctx.from_id.id_router
        else ctx.id_router = id_router
        ctx.id_target = id_target
      else if undefined !== id_router ::
        throw new Error @ `Passing 'id_router' requires 'id_target'`
      else if undefined !== reply_id && ! ctx.id_target ::
        ctx.id_router = reply_id.id_router
        ctx.id_target = reply_id.id_target

      if undefined !== token :: ctx.token = token
      if undefined !== msgid :: ctx.msgid = msgid

    return this

  withReply() ::
    return this.clone @: token: true

  reset(...args) ::
    return Object.create @ this._root_, @{}
      ctx: @: value: Object.assign @ {}, this.ctx, ...args
  clone(...args) ::
    return Object.create @ this, @{}
      ctx: @: value: Object.assign @ {}, this.ctx, ...args


  assertMonitor() ::
    if ! this.checkMonitor() ::
      throw new Error @ `Target monitor expired`
  checkMonitor() :: return true
  monitor(options={}) ::
    if true === options || false === options ::
      options = @{} active: options

    const monitor = this.endpoint.initMonitor(this.ctx.id_target)

    const ts_duration = options.ts_duration || 5000
    let ts_active = options.ts_active
    if true === ts_active ::
      ts_active = ts_duration/4

    let tid
    if options.active || ts_active ::
      const ctrl = this.codec('control')
      tid = setInterval @ ()=>ctrl.invoke('ping'), ts_active
    else ::
      tid = setInterval @ ()=>this.checkMonitor(), ts_duration/4
    if tid && tid.unref :: tid.unref()

    return new Promise @ (resolve, reject) => ::
      const done = options.reject ? reject : resolve
      this.checkMonitor = () =>
        ts_duration > monitor.td()
          ? true : (done(monitor), false)



  codec(msg_codec, ...args) ::
    if 'string' === typeof msg_codec ::
      msg_codec = this._msgCodecs[msg_codec]

    if 'function' !== typeof msg_codec.send ::
      throw new TypeError @ `Expected packet codec protocol`

    return Object.create @ this, @:
      _codec: @: value: msg_codec
      ctx: @: value: Object.assign @ {}, this.ctx, ...args

  static withCodecs(msgCodecs) ::
    for const [name, msg_codec] of Object.entries @ msgCodecs ::
      this.prototype[name] = function() ::
        return this.codec @ msg_codec
    this.prototype._msgCodecs = msgCodecs
    this.prototype._codec = msgCodecs.default
    return this

Object.assign @ MsgCtx.prototype, @{}
  ms_timeout: 5000

