import {ep_decode} from './ep_target.jsy'

export default class MsgCtx ::
  static forProtocols({random_id, codecs}) ::
    class MsgCtx extends this ::
    MsgCtx.prototype.random_id = random_id
    MsgCtx.withCodecs @ codecs
    return MsgCtx

  static forHub(hub, channel) ::
    const {sendRaw} = channel
    async function chan_send(pkt) ::
      await sendRaw(pkt)
      return true

    class MsgCtx extends this ::
    MsgCtx.prototype.chan = Object.create @
      MsgCtx.prototype.chan || null
      @{} send: @{} value: chan_send

    return MsgCtx


  constructor(id) ::
    if null != id ::
      const {id_target, id_router} = id
      const from_id = Object.freeze @: id_target, id_router
      this.ctx = @{} from_id


  withEndpoint(endpoint) ::
    return Object.defineProperties @ this, @{}
      endpoint: @{} value: endpoint
      chan: @{} value: Object.create @ this.chan


  ping(token=true) :: return this._invoke_ex(this._msgCodecs.control.ping, [], token)
  send(...args) :: return this._invoke_ex(this._codec.send, args)
  sendQuery(...args) :: return this._invoke_ex(this._codec.send, args, true)
  query(...args) :: return this._invoke_ex(this._codec.send, args, true).reply

  stream(...args) :: return this._invoke_ex @ this._codec.stream, args
  invoke(key, ...args) :: return this._invoke_ex @ this._codec[key], args
  bindInvoke(fnOrKey, token) ::
    if 'function' !== typeof fnOrKey :: fnOrKey = this._codec
    return (...args) => this._invoke_ex(fnOrKey, args, token)

  _invoke_ex(invoke, args, token) ::
    const obj = Object.assign @ {}, this.ctx
    if null == token :: token = obj.token
    else obj.token = token
    if true === token ::
      token = obj.token = this.random_id()

    this.assertMonitor()

    const res = invoke @ this.chan, obj, ...args
    if ! token || 'function' !== typeof res.then :: return res

    let p_sent  = res.then()
    const reply = this.endpoint.initReply(token, p_sent, this)
    p_sent = p_sent.then @ () => @: reply
    p_sent.reply = reply
    return p_sent

  get to() :: return (tgt, ...args) => ::
    if null == tgt :: throw new Error @ `Null target endpoint`

    const self = this.clone()

    const ctx = self.ctx
    if 'number' === typeof tgt ::
      ctx.id_target = tgt
      ctx.id_router = ctx.from_id.id_router
    else ::
      ctx.to_tgt = tgt
      tgt = ep_decode(tgt) || tgt
      const {from_id: reply_id, id_target, id_router, token, msgid} = tgt

      if undefined !== id_target ::
        ctx.id_target = id_target
        ctx.id_router = id_router
      else if undefined !== reply_id && ! ctx.id_target ::
        ctx.id_target = reply_id.id_target
        ctx.id_router = reply_id.id_router

      if undefined !== token :: ctx.token = token
      if undefined !== msgid :: ctx.msgid = msgid

    return 0 === args.length ? self : self.with @ ...args

  with(...args) ::
    const ctx = this.ctx
    for let tgt of args ::
      if true === tgt || false === tgt ::
        ctx.token = tgt
      else if null != tgt ::
        const {token, msgid} = tgt
        if undefined !== token :: ctx.token = token
        if undefined !== msgid :: ctx.msgid = msgid
    return this

  withReply() ::
    return this.clone @: token: true

  clone(...args) ::
    return Object.create @ this, @{}
      ctx: @: value: Object.assign @ {}, this.ctx, ...args


  assertMonitor() ::
    if ! this.checkMonitor() ::
      throw new Error @ `Target monitor expired`
  checkMonitor() :: return true
  monitor(options={}) ::
    if true === options || false === options ::
      options = @{} active: options

    const monitor = this.endpoint.initMonitor(this.ctx.id_target)

    const ts_duration = options.ts_duration || 5000
    let ts_active = options.ts_active
    if true === ts_active ::
      ts_active = ts_duration/4

    let checkMonitor
    const promise = new Promise @ (resolve, reject) => ::
      const done = options.reject ? reject : resolve
      this.checkMonitor = checkMonitor = () =>
        ts_duration > monitor.td()
          ? true : (done(monitor), false)

    let tid
    const ts_interval = ts_active || ts_duration/4
    if options.active || ts_active ::
      const ctrl = this.codec('control')
      const checkPing = () => ::
        if ts_interval > monitor.td() ::
          ctrl.invoke('ping')
      tid = setInterval @ checkPing, ts_interval
    else ::
      tid = setInterval @ checkMonitor, ts_interval
    if tid.unref :: tid.unref()
    const clear = () => clearInterval(tid)

    promise.then(clear, clear)
    return promise


  codec(msg_codec, ...args) ::
    if 'string' === typeof msg_codec ::
      msg_codec = this._msgCodecs[msg_codec]

    if 'function' !== typeof msg_codec.send ::
      throw new TypeError @ `Expected packet codec protocol`

    return Object.create @ this, @:
      _codec: @: value: msg_codec
      ctx: @: value: Object.assign @ {}, this.ctx, ...args

  static withCodecs(msgCodecs) ::
    for const [name, msg_codec] of Object.entries @ msgCodecs ::
      this.prototype[name] = function() ::
        return this.codec @ msg_codec
    this.prototype._msgCodecs = msgCodecs
    this.prototype._codec = msgCodecs.default

    // bind frequently used fast-path
    const send = msgCodecs.default.send
    Object.defineProperties @ this.prototype, @:
      fast: @{} get() :: return @:
        send: (...args) => this._invoke_ex(send, args)
        sendQuery: (...args) => this._invoke_ex(send, args, true)
        query: (...args) => this._invoke_ex(send, args, true).reply

    return this


  withRejectTimeout(p_reply) ::
    return new Promise @ (resolve, reject) => ::
      p_reply.then @ resolve, reject
      p_reply.then @ clear, clear

      const timeout = () => reject @ new this.ReplyTimeout
      const tid = setTimeout(timeout, this.ms_timeout)
      if tid.unref :: tid.unref()

      function clear() :: clearTimeout @ tid


class ReplyTimeout extends Error ::

Object.assign @ MsgCtx.prototype, @{}
  ReplyTimeout, ms_timeout: 5000

